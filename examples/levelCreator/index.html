<html>

<head>

    <link rel="shortcut icon" type="image/png" href="level-creator-144.png">
    <style>
        body {
            margin: 0;
        }

        .ui-top {
            position: absolute;
            top: 10px;
            left: 10px;
        }

        .ui-bottom {
            position: absolute;
            bottom: 10px;
            left: 10px;
        }

        .ui-button {
            display: inline-block;
        }

        .selected-ui {
            background-color: blue;
            color: white;
        }
    </style>
</head>

<body>
    <div class="ui-top">
        <input type="file" id="file-selector">
        <!-- <button id="load-button" class="ui-button">Load</button> -->
        <button id="save-button" class="ui-button">Save</button>
        <button id="select-button" class="ui-button">Select</button>
        <button id="generate-button" class="ui-button">Generate</button>
        <button id="teardown-button" class="ui-button">Teardown</button>
        <button id="center-button" class="ui-button">Center</button>
        <button id="line-draw-button" class="ui-button">Wall</button>
        <button id="crystal-line-draw-button" class="ui-button">Crystal Line</button>
        <button id="crystal-circle-draw-button" class="ui-button">Crystal Circle</button>
        <button id="remote-door-draw-button" class="ui-button">Remote Door</button>
        <button id="remote-switch-draw-button" class="ui-button">Remote Switch</button>
        <button id="prize-draw-button" class="ui-button">Prize</button>
        <button id="bumper-draw-button" class="ui-button">Bumper</button>
        <button id="superball-draw-button" class="ui-button">Superball</button>
        <button id="blackhole-draw-button" class="ui-button">Blackhole</button>
        <button id="guidepoint-draw-button" class="ui-button">Guidepoint</button>
    </div>
    <div class="ui-bottom">
        <div id="snaps-container">
            <span>Snaps:</span>
            <input type="checkbox" id="guidepoints-checkbox" name="guidepoint">
            <label for="guidepoints-checkbox">Guidepoints</label>
            <input type="checkbox" id="wall-endpoints-checkbox" name="wall-endpoint">
            <label for="wall-endpoints-checkbox">Wall Endpoints</label>
            <input type="checkbox" id="wall-midpoints-checkbox" name="wall-midpoint">
            <label for="wall-midpoints-checkbox">Wall Midpoints</label>
            <input type="checkbox" id="principals-checkbox" name="principal">
            <label for="principals-checkbox">Principals</label>
        </div>
    </div>
    <div id="viewport"></div>
</body>
<script type="text/javascript" src="../js/three-121.min.js"></script>
<script type="text/javascript" src="../js/THREEOrbitControls.js"></script>
<script type="text/javascript" src="./uuidv4.js"></script>
<script>
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.shadowMap.enabled = true;
    renderer.shadowMapSoft = true;
    document.getElementById("viewport").appendChild(renderer.domElement);

    const scene = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        1000
    );

    adjustCamera = 20;
    camera.position.set(0, 0, 450);
    // camera.lookAt(new THREE.Vector3(0, 10, 0));
    scene.add(camera);


    function onWindowResize(event) {
        var tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
        var windowHeight = window.innerHeight;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.fov =
            (360 / Math.PI) *
            Math.atan(tanFOV * (window.innerHeight / windowHeight));

        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);
    }
    onWindowResize();
    window.addEventListener("resize", onWindowResize, false);

    light = new THREE.SpotLight(0xffffff);
    light.position.set(20, 80, 15);
    light.target.position.copy(scene.position);
    light.castShadow = true;
    light.shadow.camera.left = -60;
    light.shadow.camera.top = -60;
    light.shadow.camera.right = 60;
    light.shadow.camera.bottom = 60;
    light.shadow.camera.near = 20;
    light.shadow.camera.far = 200;
    light.shadow.bias = -0.0001;
    light.shadow.mapSize.width = light.shadow.mapSize.height = 2048;
    scene.add(light);

    const orbitControls = new THREE.OrbitControls(camera, renderer.domElement)

    // camera.lookAt(new THREE.Vector3(0, 0, 0));
    orbitControls.update()
    const principalGeometry = new THREE.BoxGeometry(2, 2, 2)

    const principalSphereGeometry = new THREE.SphereGeometry(20, 32, 32)
    const midpointGeometry = new THREE.BoxGeometry(2, 2, 2)
    const endPointGeometry = new THREE.SphereGeometry(2, 8, 8)
    const prizeGeometry = new THREE.SphereGeometry(3, 8, 8)
    const guidepointGeometry = new THREE.BoxGeometry(2, 2, 2)
    const hotPurpleMaterial = new THREE.MeshBasicMaterial({ color: 0xeb34d8, transparent: true })
    hotPurpleMaterial.name = "hotPurpleMaterial"
    const redMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true })
    redMaterial.name = "redMaterial"
    const purpleMaterial = new THREE.MeshBasicMaterial({ color: 0x9932CC, transparent: true })
    purpleMaterial.name = "purpleMaterial"
    const greenMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true })
    greenMaterial.name = "greenMaterial"
    const blueMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true })
    blueMaterial.name = "blueMaterial"
    const orangeMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true })
    orangeMaterial.name = "orangeMaterial"
    const blackMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true })
    blackMaterial.name = "blackMaterial"
    const lineMaterial = new THREE.LineBasicMaterial({
        color: 0x0000ff, transparent: true, opacity: .5
    });
    const gridHelper = new THREE.GridHelper(200, 20);
    gridHelper.rotation.x = Math.PI / 2
    scene.add(gridHelper);

    const clickPlane = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), redMaterial);
    clickPlane.visible = false
    clickPlane.name = 'clickPlane'
    scene.add(clickPlane);


    let points = []

    let principalsInc = 0
    let beamsInc = 0
    let prizesInc = 0
    let crystalSpheresInc = 0
    let bumpersInc = 0
    let remoteDoorsInc = 0
    let crystalLinesInc = 0
    let remoteSwitchesInc = 0
    let superballsInc = 0
    let blackholesInc = 0
    let guidepointsInc = 0
    // make principals
    const positionPrincipal = (vector, index) => {
        const principals = points.filter(p => p.type === "principal")
        let x = Math.random() * 200 - 100
        let y = Math.random() * 200 - 100
        let z = 0
        vector.set(x, y, z)
        let line3 = new THREE.Line3()
        let flag = true
        for (let i = 0; i < index; i++) {
            line3.set(vector, principals[i].position)
            let distance = line3.distance()
            if (distance < 40) {
                flag = false
            }
        }
        if (flag === false) {
            return positionPrincipal(vector, index)
        }
    }
    const generatePrincipals = (config = {}) => {

        const principals = []
        const { newPoints } = config

        if (newPoints !== undefined) {
            console.log('newPoints:', newPoints)
            npTempVector = new THREE.Vector3()
            principalsInc = 0
            beamsInc = 0
            prizesInc = 0
            crystalSpheresInc = 0
            crystalLinesInc = 0
            remoteDoorsInc = 0
            bumpersInc = 0
            remoteSwitchesInc = 0
            superballsInc = 0
            blackholesInc = 0
            guidepointsInc = 0
            newPoints.forEach((p, pIndex) => {
                let newPointObj = {}
                let mesh

                if (p.uuid === undefined) {
                    newPointObj.uuid = uuidv4()
                } else {
                    newPointObj.uuid = p.uuid
                }
                switch (p.type) {
                    case 'principal':

                        mesh = new THREE.Mesh(principalSphereGeometry, redMaterial)
                        mesh.name = `principal-${principalsInc}`
                        scene.add(mesh)
                        principals.push(mesh)
                        newPointObj = { ...newPointObj, type: 'principal', radius: 20 }
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        principalsInc++
                        break;
                    case 'crystalSphere':

                        const crystalSphereGeometry = new THREE.SphereGeometry(p.radius, 32, 32)
                        mesh = new THREE.Mesh(crystalSphereGeometry, greenMaterial)
                        mesh.name = `crystalSphere-${crystalSpheresInc}`
                        scene.add(mesh)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        newPointObj = { ...newPointObj, type: 'crystalSphere', radius: p.radius }
                        crystalSpheresInc++
                        break;
                    case 'wall':
                        const boxGeometry = new THREE.BoxGeometry(p.length, 2, 3)
                        mesh = new THREE.Mesh(boxGeometry, purpleMaterial)
                        mesh.name = `wall-${beamsInc}`
                        mesh.position.set(p.position.x, p.position.y, 0)
                        mesh.rotation.z = p.rotation
                        scene.add(mesh)
                        newPointObj = { ...newPointObj, type: 'wall', rotation: mesh.rotation.z, length: p.length, v1: p.v1, v2: p.v2 }
                        beamsInc++
                        break;
                    case 'crystal-line':
                        const crystalBoxGeometry = new THREE.BoxGeometry(p.length, 2, 3)
                        mesh = new THREE.Mesh(crystalBoxGeometry, greenMaterial)
                        mesh.name = `wall-${crystalLinesInc}`
                        mesh.position.set(p.position.x, p.position.y, 0)
                        mesh.rotation.z = p.rotation
                        scene.add(mesh)
                        newPointObj = { ...newPointObj, type: 'crystal-line', rotation: mesh.rotation.z, length: p.length, v1: p.v1, v2: p.v2 }
                        crystalLinesInc++
                        break;
                    case 'prize':
                        mesh = new THREE.Mesh(prizeGeometry, purpleMaterial)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        mesh.name = `prize-${prizesInc}`
                        scene.add(mesh)
                        newPointObj = { ...newPointObj, type: 'prize', radius: 3 }
                        prizesInc++
                        break;
                    case 'bumper':
                        mesh = new THREE.Mesh(prizeGeometry, blueMaterial)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        scene.add(mesh)
                        mesh.name = `bumper-${bumpersInc}`
                        newPointObj = { ...newPointObj, type: 'bumper', radius: 3 }
                        bumpersInc++
                        break;
                    case 'remote-door':
                        mesh = new THREE.Mesh(remoteDoorGeometry, blueMaterial)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        mesh.rotation.z = p.rotation
                        scene.add(mesh)
                        mesh.name = `remote-door-${remoteDoorsInc}`
                        newPointObj = { ...newPointObj, type: 'remote-door', radius: p.radius, rotation: p.rotation, wall: p.wall }
                        remoteDoorsInc++
                        break;
                    case 'remote-switch':
                        mesh = new THREE.Mesh(prizeGeometry, orangeMaterial)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        scene.add(mesh)
                        mesh.name = `remote-switch-${remoteSwitchesInc}`
                        newPointObj = { ...newPointObj, type: 'remote-switch', radius: p.radius, remoteDoor: p.remoteDoor }
                        remoteSwitchesInc++
                    case 'superball':
                        mesh = new THREE.Mesh(endPointGeometry, redMaterial)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        scene.add(mesh)
                        mesh.name = `superball-${superballsInc}`
                        newPointObj = { ...newPointObj, type: 'superball', mesh: mesh, position: mesh.position }
                        superballsInc++
                        break;
                    case 'blackhole':
                        mesh = new THREE.Mesh(endPointGeometry, blackMaterial)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        scene.add(mesh)
                        mesh.name = `blackhole-${blackholesInc}`
                        newPointObj = { ...newPointObj, type: 'blackhole', mesh: mesh, position: mesh.position }
                        blackholesInc++
                        break;
                    case 'guidepoint':
                        mesh = new THREE.Mesh(guidepointGeometry, hotPurpleMaterial)
                        mesh.position.set(p.position.x, p.position.y, p.position.z)
                        scene.add(mesh)
                        mesh.name = `guidepoint-${guidepointsInc}`
                        newPointObj = { ...newPointObj, type: 'guidepoint', mesh: mesh, position: mesh.position, uuid: uuidv4() }
                        guidepointsInc++
                        break;
                    default:
                        break;
                }
                if (mesh !== undefined) {
                    newPointObj = { ...newPointObj, mesh: mesh, position: mesh.position }
                    points.push(newPointObj)
                } else {

                    console.log('couldnt handle', p)
                }



            })
        } else {

            for (let i = 0; i < 5; i++) {
                const principal = new THREE.Mesh(principalSphereGeometry, redMaterial)
                principal.name = `principal-${principalsInc}`
                scene.add(principal)
                principals.push(principal)
                points.push({ type: 'principal', mesh: principal, position: principal.position, radius: 20 })
                principalsInc++
                positionPrincipal(principal.position, i)
            }

        }

        // make midpoints and lines
        for (let i = 0; i < principals.length - 1; i++) {
            for (let j = i + 1; j < principals.length; j++) {
                //principals[i] is p1, principals[j] is p2

                //make midpoints
                const midpoint = new THREE.Mesh(midpointGeometry, greenMaterial)
                midpoint.position.set((principals[i].position.x + principals[j].position.x) / 2,
                    (principals[i].position.y + principals[j].position.y) / 2,
                    (principals[i].position.z + principals[j].position.z) / 2)

                midpoint.name = `midpoint-${i}-${j}`
                scene.add(midpoint)
                points.push({ type: 'midpoint', mesh: midpoint, position: midpoint.position })

                //make lines
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([principals[i].position, principals[j].position]), lineMaterial)
                const line3 = new THREE.Line3(principals[i].position, principals[j].position)
                line.name = `line-${i}-${j}`
                points.push({ type: 'line', mesh: line, position: line.position })

                scene.add(line)
            }
        }
    }

    const getRadiusThatFits = (vector, radius) => {
        let fits = true
        points.forEach(point => {
            if (fits === true) {
                let line3 = new THREE.Line3(vector, point.position)
                let distance = line3.distance()
                if (point.radius !== undefined && (distance < (radius + point.radius))) {
                    fits = false
                }
            }
        })
        if (fits === false && radius > 1) {
            return getRadiusThatFits(vector, --radius)
        } else {
            return radius
        }
    }
    const generateCrystals = () => {
        points.filter(p => p.type === "midpoint")
            .forEach((midpoint, midpointIndex) => {
                if (midpointIndex !== undefined) {
                    // make coins
                    let vector = midpoint.position.clone()
                    let radius = getRadiusThatFits(vector, 30)
                    const crystalSphere = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), greenMaterial)
                    crystalSphere.name = `crystal-sphere-${crystalSpheresInc}`
                    scene.add(crystalSphere)
                    crystalSphere.position.set(midpoint.position.x, midpoint.position.y, midpoint.position.z)
                    points.push({ type: 'crystalSphere', mesh: crystalSphere, position: crystalSphere.position, radius: radius, uuid: uuidv4() })
                    crystalSpheresInc++
                }
            })
    }
    //get center and translate all points
    const getCenterVector = () => {
        const principals = points.filter(p => p.type === "principal")
        const vector = new THREE.Vector3(0, 0, 0)
        const axes = ['x', 'y', 'z']
        axes.forEach(axis => {
            sum = 0
            principals.forEach(principal => {
                sum += principal.position[axis]
            })
            vector[axis] = sum / principals.length
        })
        return vector
    }


    //teardown
    const teardownPoints = () => {
        points.forEach(p => {

            p.mesh !== undefined && scene.remove(p.mesh)
        })
        points = []
    }


    //method that creates a rectangle (wall) from two points


    const createWall = (v1, v2) => {
        const v1Sphere = new THREE.Mesh(endPointGeometry, greenMaterial)
        v1Sphere.position.copy(v1)
        const v2Sphere = new THREE.Mesh(endPointGeometry, purpleMaterial)
        v2Sphere.position.copy(v2)
        scene.add(v1Sphere)
        scene.add(v2Sphere)
        let line3 = new THREE.Line3(v1, v2)
        let yDiff = v2.y - v1.y
        let xDiff = v2.x - v1.x
        let angle = Math.atan2(yDiff, xDiff)
        let distance = line3.distance()
        const boxGeometry = new THREE.BoxGeometry(distance, 2, 3)
        const wall = new THREE.Mesh(boxGeometry, purpleMaterial)
        wall.name = `wall-${beamsInc}`
        line3.getCenter(wall.position)
        wall.rotation.z = angle
        scene.add(wall)
        points.push({ type: 'wall', mesh: wall, position: wall.position, rotation: angle, length: distance, v1: v1, v2: v2, uuid: uuidv4() })
        beamsInc++
    }
    const createCrystalWall = (v1, v2) => {
        const v1Sphere = new THREE.Mesh(endPointGeometry, greenMaterial)
        v1Sphere.position.copy(v1)
        const v2Sphere = new THREE.Mesh(endPointGeometry, purpleMaterial)
        v2Sphere.position.copy(v2)
        scene.add(v1Sphere)
        scene.add(v2Sphere)
        let line3 = new THREE.Line3(v1, v2)
        let yDiff = v2.y - v1.y
        let xDiff = v2.x - v1.x
        let angle = Math.atan2(yDiff, xDiff)
        let distance = line3.distance()
        const boxGeometry = new THREE.BoxGeometry(distance, 2, 3)
        const wall = new THREE.Mesh(boxGeometry, greenMaterial)
        wall.name = `crystal-line-${crystalLinesInc}`
        line3.getCenter(wall.position)
        wall.rotation.z = angle
        scene.add(wall)
        points.push({ type: 'crystal-line', mesh: wall, position: wall.position, rotation: angle, length: distance, v1: v1, v2: v2, uuid: uuidv4() })
        crystalLinesInc++
    }
    let currentSphereRadius = 1
    const createCrystalCircle = (v1) => {
        const crystalSphere = new THREE.Mesh(crystalCircleGeometry, greenMaterial)
        crystalSphere.name = `crystal-sphere-${crystalSpheresInc}`
        crystalSphere.scale.set(currentSphereRadius, currentSphereRadius, currentSphereRadius)
        scene.add(crystalSphere)
        crystalSphere.position.set(v1.x, v1.y, v1.z)
        points.push({ type: 'crystalSphere', mesh: crystalSphere, position: crystalSphere.position, radius: currentSphereRadius, uuid: uuidv4() })
        crystalSpheresInc++
    }
    const createPrize = (v) => {
        const prize = new THREE.Mesh(prizeGeometry, purpleMaterial)
        prize.position.copy(v)
        scene.add(prize)
        prize.name = `prize-${prizesInc}`
        points.push({ type: 'prize', mesh: prize, position: prize.position, radius: 3, uuid: uuidv4() })
        prizesInc++
    }
    const createBumper = (v) => {
        const bumper = new THREE.Mesh(prizeGeometry, blueMaterial)
        bumper.position.copy(v)
        scene.add(bumper)
        bumper.name = `bumper-${bumpersInc}`
        points.push({ type: 'bumper', mesh: bumper, position: bumper.position, radius: 3, uuid: uuidv4() })
        bumpersInc++
    }
    const remoteDoorGeometry = new THREE.BoxGeometry(10, 3, 3)
    const createRemoteDoor = (v) => {
        const door = new THREE.Mesh(remoteDoorGeometry, blueMaterial)
        door.position.copy(v)
        scene.add(door)
        door.name = `remove-door${remoteDoorsInc}`
        door.rotation.z = remoteDoorAngle
        points.push({ type: 'remote-door', rotation: remoteDoorAngle, mesh: door, position: door.position, radius: 3, wall: remoteDoorPointUuid, uuid: uuidv4() })
        lastSelectedRemoteDoorPoint = points[points.length - 1]
        remoteDoorsInc++
    }

    let lastSelectedRemoteDoorPoint = undefined
    const createRemoteSwitch = (v) => {
        if (lastSelectedRemoteDoorPoint !== undefined) {
            const remoteSwitch = new THREE.Mesh(prizeGeometry, orangeMaterial)
            remoteSwitch.position.copy(v)
            scene.add(remoteSwitch)
            remoteSwitch.name = `remote-switch-${remoteSwitchesInc}`
            points.push({ type: 'remote-switch', mesh: remoteSwitch, position: remoteSwitch.position, radius: 3, remoteDoor: lastSelectedRemoteDoorPoint.uuid, uuid: uuidv4() })
            remoteSwitchesInc++
        }
    }
    const createSuperball = (v) => {
        const superball = new THREE.Mesh(endPointGeometry, redMaterial)
        superball.position.copy(v)
        scene.add(superball)
        superball.name = `superball-${superballsInc}`
        points.push({ type: 'superball', mesh: superball, position: superball.position, uuid: uuidv4() })
        superballsInc++
    }
    const createBlackhole = (v) => {
        const blackhole = new THREE.Mesh(endPointGeometry, blackMaterial)
        blackhole.position.copy(v)
        scene.add(blackhole)
        blackhole.name = `blackhole-${blackholesInc}`
        points.push({ type: 'blackhole', mesh: blackhole, position: blackhole.position, uuid: uuidv4() })
        blackholesInc++
    }
    const createGuidepoint = (v) => {
        const guidepoint = new THREE.Mesh(guidepointGeometry, hotPurpleMaterial)
        guidepoint.position.copy(v)
        scene.add(guidepoint)
        guidepoint.name = `guidepoint-${guidepointsInc}`
        points.push({ type: 'guidepoint', mesh: guidepoint, position: guidepoint.position, uuid: uuidv4() })
        guidepointsInc++
    }


    const clickRaycaster = new THREE.Raycaster();
    const mouseClickCoords = new THREE.Vector2();
    const moveRaycaster = new THREE.Raycaster();
    const mouseMoveCoords = new THREE.Vector2();
    let hoverMeshes = []
    // let lsObj = {
    //     mesh: undefined,
    //     cacheMaterial:undefined,
    // }
    let lastSelected = []
    for (let i = 0; i < 100; i++) {
        // lastSelected.push(lsObj)
        lastSelected[i] = {}
        lastSelected[i].mesh = undefined
        lastSelected[i].material = new THREE.MeshBasicMaterial()
        lastSelected[i].cacheMaterial = undefined
    }

    function onDocumentMouseDown(event) {
        // event.stopPropagation();
        mouseClickCoords.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouseClickCoords.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        clickRaycaster.setFromCamera(mouseClickCoords, camera);
        const intersects = clickRaycaster.intersectObjects(scene.children);
        const clickPlaneIntersect = intersects.find(int => int.object.name === "clickPlane")
        if (clickPlaneIntersect !== undefined) {
            switch (toolSelected) {
                case "line-draw":
                    if (hoverMeshes[0] !== undefined && hoverMeshes[0].visible === true) {
                        // debugger
                        lineDrawPoints.push(hoverMeshes[0].position.clone())
                    }
                    if (lineDrawPoints.length >= 2) {
                        createWall(lineDrawPoints[lineDrawPoints.length - 1], lineDrawPoints[lineDrawPoints.length - 2])
                    }
                    break;
                case "crystal-line-draw":
                    if (hoverMeshes[0] !== undefined && hoverMeshes[0].visible === true) {
                        crystalLineDrawPoints.push(hoverMeshes[0].position.clone())
                    }
                    if (crystalLineDrawPoints.length >= 2) {
                        createCrystalWall(crystalLineDrawPoints[crystalLineDrawPoints.length - 1], crystalLineDrawPoints[crystalLineDrawPoints.length - 2])
                    }
                    break;
                case "crystal-circle-draw":
                    createCrystalCircle(hoverMeshes[0].position)
                    break;
                case 'prize-draw':
                    createPrize(hoverMeshes[0].position)
                    break;
                case 'bumper-draw':
                    createBumper(hoverMeshes[0].position)
                    break;
                case 'remote-door-draw':
                    createRemoteDoor(hoverMeshes[0].position)
                    break;
                case 'remote-switch-draw':
                    createRemoteSwitch(hoverMeshes[0].position)
                    break;
                case 'superball-draw':
                    createSuperball(hoverMeshes[0].position)
                    break;
                case 'blackhole-draw':
                    createBlackhole(hoverMeshes[0].position)
                    break;
                case 'guidepoint-draw':
                    createGuidepoint(hoverMeshes[0].position)
                    break;
                case 'select':
                    let pointsIntersects = clickRaycaster.intersectObjects(points.filter(point => point.mesh !== undefined).map(point => point.mesh));
                    pointsIntersects = pointsIntersects.filter(pi => pi.object.name.startsWith('midpoint') === false && pi.object.name.startsWith('line') === false)

                    if (pointsIntersects.length > 0) {
                        let alreadySelectedIndex = lastSelected.findIndex(ls => {
                            if (ls.mesh !== undefined && ls.mesh.uuid === pointsIntersects[0].object.uuid) {
                                return true
                            } else {
                                return false
                            }
                        })
                        console.log(alreadySelectedIndex)
                        if (alreadySelectedIndex === -1) {
                            let lastSelectedPoint = points.find(p => p.mesh.uuid === pointsIntersects[0].object.uuid)
                            console.log('LSP', lastSelectedPoint)
                            switch (lastSelectedPoint.type) {
                                case 'remote-door':
                                    lastSelectedRemoteDoorPoint = lastSelectedPoint
                                    break;
                                default:
                                    break;
                            }
                            // console.log('shiftKey', event.shiftKey)
                            let sIndex = 0
                            if (event.shiftKey === true) {
                                sIndex = lastSelected.findIndex(ls => ls.mesh === undefined)
                            } else {
                                if (lastSelected[sIndex].mesh !== undefined) {
                                    lastSelected[sIndex].mesh.material = lastSelected[sIndex].cacheMaterial
                                }
                            }
                            // console.log('sIndex', sIndex)
                            lastSelected[sIndex].mesh = pointsIntersects[0].object
                            lastSelected[sIndex].cacheMaterial = lastSelected[sIndex].mesh.material
                            lastSelected[sIndex].material.copy(lastSelected[sIndex].mesh.material)
                            lastSelected[sIndex].material.opacity = .5
                            lastSelected[sIndex].mesh.material = lastSelected[sIndex].material
                            if (event.shiftKey === false) {
                                // console.log('UNSELECT AFTER', sIndex)
                                let until = lastSelected.findIndex(ls => {
                                    // console.log(ls)
                                    // debugger
                                    return ls.mesh === undefined
                                })
                                // console.log('until', until)
                                // debugger
                                for (let i = sIndex + 1; i < until; i++) {
                                    // console.log('unselecting mesh', i)
                                    lastSelected[i].mesh.material = lastSelected[i].cacheMaterial
                                    lastSelected[i].mesh = undefined
                                }
                            }
                        }
                    } else {
                        console.log('UNSELECT ALL')
                        let until = lastSelected.findIndex(ls => ls.mesh === undefined)
                        console.log('until', until)
                        for (let i = 0; i < until; i++) {
                            lastSelected[i].mesh.material = lastSelected[i].cacheMaterial
                            lastSelected[i].mesh = undefined
                        }
                    }

                    break;
            }
        }
    }
    document.addEventListener('keydown', e => {
        switch (toolSelected) {
            case 'select':
                // console.log('lastSelected', lastSelected)
                let i = 0
                switch (e.keyCode) {
                    case 37: //left
                        e.preventDefault()
                        e.stopPropagation()
                        while (lastSelected[i].mesh !== undefined) {
                            lastSelected[i].mesh.position.x = lastSelected[i].mesh.position.x - 1
                            i++
                        }
                        break;
                    case 39: //right
                        e.preventDefault()
                        e.stopPropagation()
                        while (lastSelected[i].mesh !== undefined) {
                            lastSelected[i].mesh.position.x = lastSelected[i].mesh.position.x + 1
                            i++
                        }
                        break;
                    case 38: //up
                        e.preventDefault()
                        e.stopPropagation()
                        while (lastSelected[i].mesh !== undefined) {
                            lastSelected[i].mesh.position.y = lastSelected[i].mesh.position.y + 1
                            i++
                        }
                        break;
                    case 40: //down
                        e.preventDefault()
                        e.stopPropagation()
                        while (lastSelected[i].mesh !== undefined) {
                            lastSelected[i].mesh.position.y = lastSelected[i].mesh.position.y - 1
                            i++
                        }
                        break;
                    case 46: //delete
                        e.preventDefault()
                        e.stopPropagation()
                        while (lastSelected[i].mesh !== undefined) {
                            scene.remove(lastSelected[i].mesh)
                            points.splice(points.findIndex(p => p.mesh.uuid === lastSelected[i].mesh.uuid), 1)
                            i++
                        }
                        break;
                    default:
                        break;
                }

                break;
            case 'crystal-circle-draw':
                switch (e.keyCode) {
                    case 81: //q
                        console.log('q')
                        e.preventDefault()
                        e.stopPropagation()
                        if (currentSphereRadius > 0 && toolSelected === 'crystal-circle-draw') {
                            currentSphereRadius--
                            console.log('currentSphereRadius', currentSphereRadius)
                            hoverMeshes[0].scale.set(currentSphereRadius, currentSphereRadius, currentSphereRadius)
                        }
                        break;
                    case 87: //w
                        console.log('w')
                        e.preventDefault()
                        e.stopPropagation()
                        if (toolSelected === 'crystal-circle-draw') {
                            currentSphereRadius++
                            console.log('currentSphereRadius', currentSphereRadius)
                            hoverMeshes[0].scale.set(currentSphereRadius, currentSphereRadius, currentSphereRadius)
                        }
                        break;
                    default:
                        break;

                }
                break;
            default:
                break;
        }
    })


    let lineDrawPoints = []
    let crystalLineDrawPoints = []
    let toolSelected = ''
    const crystalCircleGeometry = new THREE.SphereGeometry(1, 8, 8)
    const drawTools = [
        {
            name: 'line-draw',
            clickFunction: () => {
                lineDrawPoints = []
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(endPointGeometry, greenMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = endPointGeometry
                    hoverMeshes[0].material.copy(greenMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
                if (hoverMeshes[1] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(new THREE.BoxGeometry(1, 2, 3), purpleMaterial.clone()))
                    hoverMeshes[1].material.opacity = .5
                    scene.add(hoverMeshes[1])
                } else {
                    hoverMeshes[1].geometry = new THREE.BoxGeometry(1, 2, 3)
                    hoverMeshes[1].material.copy(purpleMaterial)
                    hoverMeshes[1].material.opacity = .5
                    hoverMeshes[1].visible = false
                }
            }
        },
        {
            name: 'crystal-line-draw',
            clickFunction: () => {
                crystalLineDrawPoints = []
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(endPointGeometry, greenMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = endPointGeometry
                    hoverMeshes[0].material.copy(greenMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
                if (hoverMeshes[1] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(new THREE.BoxGeometry(1, 2, 3), greenMaterial.clone()))
                    hoverMeshes[1].material.opacity = .5
                    scene.add(hoverMeshes[1])
                } else {
                    hoverMeshes[1].geometry = new THREE.BoxGeometry(1, 2, 3)
                    hoverMeshes[1].material.copy(greenMaterial)
                    hoverMeshes[1].material.opacity = .5
                    hoverMeshes[1].visible = false
                }
            }
        },
        {
            name: 'prize-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(prizeGeometry, purpleMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = prizeGeometry
                    hoverMeshes[0].material.copy(purpleMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }

            }
        },
        {
            name: 'bumper-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(prizeGeometry, blueMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = prizeGeometry
                    hoverMeshes[0].material.copy(blueMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
            }
        },
        {
            name: 'remote-door-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(remoteDoorGeometry, blueMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = remoteDoorGeometry
                    hoverMeshes[0].material.copy(blueMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
            }
        },
        {
            name: 'remote-switch-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(prizeGeometry, orangeMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = prizeGeometry
                    hoverMeshes[0].material.copy(orangeMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
            }
        },
        {
            name: 'crystal-circle-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(crystalCircleGeometry, greenMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = crystalCircleGeometry
                    hoverMeshes[0].material.copy(greenMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
            }
        },
        {
            name: 'superball-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(endPointGeometry, redMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = endPointGeometry
                    hoverMeshes[0].material.copy(redMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
            }
        },
        {
            name: 'blackhole-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(endPointGeometry, blackMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = endPointGeometry
                    hoverMeshes[0].material.copy(blackMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
            }
        },
        {
            name: 'guidepoint-draw',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {
                if (hoverMeshes[0] === undefined) {
                    hoverMeshes.push(new THREE.Mesh(guidepointGeometry, hotPurpleMaterial.clone()))
                    hoverMeshes[0].material.opacity = .5
                    scene.add(hoverMeshes[0])
                } else {
                    hoverMeshes[0].geometry = guidepointGeometry
                    hoverMeshes[0].material.copy(hotPurpleMaterial)
                    hoverMeshes[0].material.opacity = .5
                    hoverMeshes[0].visible = true
                }
            }
        },
        {
            name: 'select',
            clickFunction: () => {
            },
            hoverMeshFunction: () => {

                if (hoverMeshes[0] !== undefined) {
                    hoverMeshes[0].visible = false
                }
                if (hoverMeshes[1] !== undefined) {
                    hoverMeshes[1].visible = false
                }
            }
        }
    ]
    const registerDrawTool = (config) => {
        const { name, clickFunction, hoverMeshFunction } = config
        document.querySelector(`#${name}-button`).addEventListener('click', (e) => {
            e.stopPropagation()
            if (toolSelected !== name) {
                toolSelected = name
                document.querySelector(`#${name}-button`).classList.add('selected-ui')
                Array.from(document.querySelector('.ui-top').children).forEach(child => {
                    child.id !== e.target.id && child.classList.remove('selected-ui')
                })
                lineDrawPoints = []
                crystalLineDrawPoints = []
                clickFunction()
                hoverMeshFunction()
            } else if (toolSelected === name) {
                toolSelected = ''
                hoverMeshes.forEach(mesh => {
                    mesh.visible = false
                })
                document.querySelector(`#${name}-button`).classList.remove('selected-ui')
            }
        })
    }
    drawTools.forEach(tool => {
        registerDrawTool(tool)
    })
    
    Array.from(document.querySelectorAll('#snaps-container input[type="checkbox"]'))
    .forEach(checkbox => {
        checkbox.addEventListener('click', e => {
            e.stopPropagation()
        })
    })

    document.querySelector('#center-button').addEventListener('click', (e) => {
        e.stopPropagation()
        const centerVector = getCenterVector()
        points.forEach(point => {
            point.position.set(point.position.x - centerVector.x, point.position.y - centerVector.y, point.position.z - centerVector.z)
        })
    })
    document.querySelector('#generate-button').addEventListener('click', (e) => {
        e.stopPropagation()
        generatePrincipals()
        generateCrystals()
    })

    document.querySelector('#teardown-button').addEventListener('click', (e) => {
        e.stopPropagation()
        teardownPoints()
    })

    document.querySelector('#save-button').addEventListener('click', (e) => {
        e.stopPropagation()
        let strippedPoints = [...points]
        strippedPoints.forEach(point => {
            delete point.mesh
        })
        strippedPoints = strippedPoints.filter(point => point.type !== 'midpoint' && point.type !== 'line')
        let fileContent = JSON.stringify(strippedPoints);
        let bb = new Blob([fileContent], { type: 'text/json' });
        let a = document.createElement('a');
        a.download = 'levelCreator.json';
        a.href = window.URL.createObjectURL(bb);
        a.click();
    })

    let loadedPointsData
    if (window.FileList && window.File) {
        document.getElementById('file-selector').addEventListener('change', event => {
            for (const file of event.target.files) {
                file.text().then((res) => {
                    teardownPoints()
                    generatePrincipals({ newPoints: JSON.parse(res) })
                })
            }
        });
        document.getElementById('file-selector').addEventListener('click', event => {
            event.stopPropagation()
        })
    } else {
        console.warn('file loading unsupported')
    }


    document.querySelector('body').addEventListener('click', (e) => {
        onDocumentMouseDown(e)
    })


    let mousemoveLine30 = new THREE.Line3()
    let mousemoveLine31 = new THREE.Line3()
    let mousemoveVector = new THREE.Vector3()
    let mousemoveClosestVector = new THREE.Vector3()
    let remoteDoorPointUuid = ''
    let remoteDoorAngle = 0

    const snapTo = (config) => {
        const { point, snaps, radius } = config
        // console.log(snaps)
        snapPointUuid = ''
        const snapPoints = points.filter(p => snaps.indexOf(p.type) > -1)
        if (snaps.includes('wall-endpoint')) {
            points.forEach(p => {
                if (p.type === 'wall') {
                    snapPoints.push({ position: { x: p.v1.x, y: p.v1.y, z: p.v1.z } })
                    snapPoints.push({ position: { x: p.v2.x, y: p.v2.y, z: p.v2.z } })
                }
            })
        }
        if (snaps.includes('wall-midpoint')) {
            points.forEach(p => {
                if (p.type === 'wall') {
                    mousemoveLine30.set(p.v1,p.v2)
                    mousemoveLine30.getCenter(mousemoveVector)
                    snapPoints.push({ position: { x: mousemoveVector.x, y: mousemoveVector.y, z: mousemoveVector.z } })
                }
            })
        }
        let closestDistance = 3000
        let currentDistance = 3000
        // console.log(snapPoints)
        snapPoints.forEach(sp => {
            mousemoveVector.set(sp.position.x, sp.position.y, sp.position.z)
            mousemoveLine30.set(point, mousemoveVector)
            currentDistance = mousemoveLine30.distance()
            if (currentDistance <= radius && currentDistance < closestDistance) {
                closestDistance = currentDistance
                mousemoveClosestVector.copy(mousemoveVector)
            }
        })
        if (closestDistance !== 3000) {
            hoverMeshes[0].position.copy(mousemoveClosestVector)
        }
    }


    document.querySelector('body').addEventListener('mousemove', (e) => {
        e.stopPropagation();
        mouseMoveCoords.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouseMoveCoords.y = - (e.clientY / renderer.domElement.clientHeight) * 2 + 1;
        moveRaycaster.setFromCamera(mouseMoveCoords, camera);
        const intersects = moveRaycaster.intersectObjects(scene.children);
        const clickPlaneIntersect = intersects.find(int => int.object.name === "clickPlane")
        if (hoverMeshes[0] !== undefined && clickPlaneIntersect !== undefined) {
            hoverMeshes[0].position.set(clickPlaneIntersect.point.x, clickPlaneIntersect.point.y, clickPlaneIntersect.point.z)
            switch (toolSelected) {
                case 'remote-door-draw':
                    const walls = points.filter(point => point.type === 'wall')
                    let closestDistance = 3000
                    let currentDistance = 3000
                    walls.forEach(wall => {
                        mousemoveLine30.set(wall.v1, wall.v2)
                        mousemoveLine30.closestPointToPoint(clickPlaneIntersect.point, true, mousemoveVector)
                        mousemoveLine31.set(clickPlaneIntersect.point, mousemoveVector)
                        currentDistance = mousemoveLine31.distance()
                        if (currentDistance < closestDistance) {
                            closestDistance = currentDistance
                            mousemoveClosestVector.copy(mousemoveVector)
                            // debugger
                            remoteDoorPointUuid = wall.uuid
                            remoteDoorAngle = Math.atan2(wall.v2.y - wall.v1.y, wall.v2.x - wall.v1.x)
                        }
                    })
                    hoverMeshes[0].rotation.z = remoteDoorAngle
                    hoverMeshes[0].position.copy(mousemoveClosestVector)
                    // debugger
                    break;
                default:
                    let tempSnaps = []
                    Array.from(document.querySelectorAll('#snaps-container input[type="checkbox"]'))
                        .forEach(checkbox => {
                            if (checkbox.checked === true){
                                tempSnaps.push(checkbox.name)
                            }
                        })
                    snapTo({
                        point: clickPlaneIntersect.point,
                        snaps: tempSnaps,
                        radius: 6
                    })
                    break;
            }
        }
        if (hoverMeshes[1] !== undefined) {
            switch (toolSelected) {
                case 'line-draw':
                    if (lineDrawPoints.length >= 1) {

                        let v1 = lineDrawPoints[lineDrawPoints.length - 1]
                        let v2 = hoverMeshes[0].position
                        mousemoveLine31.set(v1, v2)
                        let angle = Math.atan2(v2.y - v1.y, v2.x - v1.x)
                        let distance = mousemoveLine31.distance()
                        hoverMeshes[1].scale.set(distance, 1, 1)
                        mousemoveLine31.getCenter(hoverMeshes[1].position)
                        hoverMeshes[1].rotation.z = angle
                        hoverMeshes[1].visible = true
                    }
                    break;
                case 'crystal-line-draw':
                    if (crystalLineDrawPoints.length >= 1) {

                        let v1 = crystalLineDrawPoints[crystalLineDrawPoints.length - 1]
                        let v2 = hoverMeshes[0].position
                        mousemoveLine31.set(v1, v2)
                        let angle = Math.atan2(v2.y - v1.y, v2.x - v1.x)
                        let distance = mousemoveLine31.distance()
                        hoverMeshes[1].scale.set(distance, 1, 1)
                        mousemoveLine31.getCenter(hoverMeshes[1].position)
                        hoverMeshes[1].rotation.z = angle
                        hoverMeshes[1].visible = true
                    }
                    break;
                default:
                    break;
            }
        }
    })
    // document.querySelector('canvas').addEventListener('wheel', (e) => {
    //     e.stopPropagation();
    //     e.preventDefault();

    //     console.log(e.deltaY)
    // })

    render = function () {
        requestAnimationFrame(render);
        orbitControls.update()
        renderer.render(scene, camera);
    };
    requestAnimationFrame(render)
</script>

</html>