<!DOCTYPE html>

<html>
  <head>
    <title>Collisions - Physijs</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
      }
    </style>

    <script type="text/javascript" src="js/ammo.js"></script>
    <script type="text/javascript" src="js/three-121.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="js/physi.js"></script>
    <script type="text/javascript" src="js/physijs_worker.js"></script>
    <script type="text/javascript" src="js/THREEOrbitControls.js"></script>

    <script type="text/javascript">
      "use strict";

      Physijs.scripts.worker = "js/physijs_worker.js";
      Physijs.scripts.ammo = "ammo.js";

      var initScene,
        render,
        _boxes = [],
        spawnBox,
        loader,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground_material,
        ground,
        light,
        camera,
        orbitControls;

      initScene = function () {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById("viewport").appendChild(renderer.domElement);

        render_stats = new Stats();
        render_stats.domElement.style.position = "absolute";
        render_stats.domElement.style.top = "0px";
        render_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(render_stats.domElement);

        physics_stats = new Stats();
        physics_stats.domElement.style.position = "absolute";
        physics_stats.domElement.style.top = "50px";
        physics_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(physics_stats.domElement);

        scene = new Physijs.Scene();
        scene.setGravity(new THREE.Vector3(0, -30, 0));
        scene.addEventListener("update", function () {
          scene.simulate(undefined, 1);
          physics_stats.update();
        });

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(0, 25, 100);
        camera.lookAt(scene.position);
        scene.add(camera);

        // Light
        light = new THREE.SpotLight(0xffffff);
        light.position.set(20, 80, 15);
        light.target.position.copy(scene.position);
        light.castShadow = true;
        light.shadowCameraLeft = -60;
        light.shadowCameraTop = -60;
        light.shadowCameraRight = 60;
        light.shadowCameraBottom = 60;
        light.shadowCameraNear = 20;
        light.shadowCameraFar = 200;
        light.shadowBias = -0.0001;
        light.shadowMapWidth = light.shadowMapHeight = 2048;
        light.shadowDarkness = 0.7;
        scene.add(light);

        // Orbit Controls
		orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
		orbitControls.enableRotate = false

        //resize event handler
        function onWindowResize(event) {
          // remember these initial values
          var tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
          var windowHeight = window.innerHeight;
          camera.aspect = window.innerWidth / window.innerHeight;

          // adjust the FOV
          camera.fov =
            (360 / Math.PI) *
            Math.atan(tanFOV * (window.innerHeight / windowHeight));

          camera.updateProjectionMatrix();
          camera.lookAt(scene.position);

          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.render(scene, camera);
        }
        onWindowResize();
        window.addEventListener("resize", onWindowResize, false);

        // Loader

        loader = new THREE.TextureLoader();

        // Ground
        ground_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            map: loader.load("images/rocks.jpg"),
          }),
          0.8, // high friction
          0.3 // low restitution
        );
        ground_material.map.wrapS = ground_material.map.wrapT =
          THREE.RepeatWrapping;
        ground_material.map.repeat.set(3, 3);

        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(100, 1, 100),
          ground_material,
          0 // mass
        );

        let features = [];

        const groundBox = new Physijs.BoxMesh(
          new THREE.BoxGeometry(10, 1, 10),
          new THREE.MeshPhongMaterial({ color: "red" }),
          0 // mass
        );
        groundBox.position.y = randomNumber(5);
        groundBox.position.x = randomNumber(5);
        groundBox.position.__dirtyPosition = true;
        groundBox.setLinearVelocity(new THREE.Vector3(0, 0, 0));
        groundBox.setAngularVelocity(new THREE.Vector3(0, 0, 0));
        groundBox.castShadow = true;
		groundBox.receiveShadow = true;
		groundBox.rotation.x = Math.random() * 2 * Math.PI
		groundBox.rotation.y = Math.random() * 2 * Math.PI
		// groundBox.rotation.z = Math.random() * 2 * Math.PI

        const groundBox1 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(30, 1, 10),
          new THREE.MeshPhongMaterial({ color: "red" }),
          0 // mass
		);
		function randomNumber(n) {
			return Math.round(Math.random() * n)
		}
        groundBox1.position.y = randomNumber(10);
        groundBox1.position.x = randomNumber(20);
        groundBox1.position.z = randomNumber(-10);
        groundBox1.position.__dirtyPosition = true;
        groundBox1.setLinearVelocity(new THREE.Vector3(0, 0, 0));
        groundBox1.setAngularVelocity(new THREE.Vector3(0, 0, 0));
        groundBox1.castShadow = true;
        groundBox1.receiveShadow = true;
		groundBox1.rotation.x = Math.random() * 2 * Math.PI
		groundBox1.rotation.y = Math.random() * 2 * Math.PI
		// groundBox1.rotation.z = Math.random() * 2 * Math.PI

        const groundBox2 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(30, 1, 10),
          new THREE.MeshPhongMaterial({ color: "red" }),
          0 // mass
        );
        groundBox2.position.x = randomNumber(-15);
        groundBox2.position.y = randomNumber(15);
        groundBox2.position.__dirtyPosition = true;
        groundBox2.setLinearVelocity(new THREE.Vector3(0, 0, 0));
        groundBox2.setAngularVelocity(new THREE.Vector3(0, 0, 0));
        groundBox2.castShadow = true;
		groundBox2.receiveShadow = true;
		groundBox2.rotation.x = Math.random() * 2 * Math.PI
		groundBox2.rotation.y = Math.random() * 2 * Math.PI
		// groundBox2.rotation.z = Math.random() * 2 * Math.PI

        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(groundBox);
        scene.add(groundBox1);
        scene.add(groundBox2);
        spawnBox();

        requestAnimationFrame(render);
		scene.simulate();

		window.appConfig = {
			touchStart: false,
			touchEnd: false,
			currentX: 0,
			currentY: 0,
			prevX: 0,
			prevY: 0,
			diffX: 0,
			diffY: 0
		}
		document.addEventListener('touchstart', (e) => {
			window.appConfig.touchEnd = false
			window.appConfig.touchStart = true
			window.appConfig.currentX = e.touches[0].clientX
			window.appConfig.currentY = e.touches[0].clientY

			window.appConfig.prevX = e.touches[0].clientX
			window.appConfig.prevY = e.touches[0].clientY
			window.appConfig.diffX = window.appConfig.currentX - window.appConfig.prevX
			window.appConfig.diffY = window.appConfig.currentY - window.appConfig.prevY
			console.log('TOUCHSTART', e)
			console.log('APPCONFIG', window.appConfig)
		})
		// document.addEventListener('mousemove', (e) => {
		// 	console.log('MOUSEMOVE', e.clientX, e.clientY)
		// })
		document.body.addEventListener('touchmove', (e) => {
			window.appConfig.prevX = window.appConfig.currentX
			window.appConfig.prevY = window.appConfig.currentY
			window.appConfig.currentX = e.touches[0].clientX
			window.appConfig.currentY = e.touches[0].clientY
			window.appConfig.diffX = e.touches[0].clientX - window.appConfig.prevX
			window.appConfig.diffY = e.touches[0].clientY - window.appConfig.prevY
			console.log('TOUCHMOVE', e.touches[0].clientX, e.touches[0].clientY)
			console.log('APPCONFIG', window.appConfig)
			console.log(window.appConfig.diffX, window.appConfig.diffY)
		}, true)
		document.addEventListener('touchend', (e) => {
			window.appConfig.touchEnd = true
			window.appConfig.touchStart = false
			window.appConfig.currentX = 0
			window.appConfig.currentY = 0
			window.appConfig.diffX = 0
			window.appConfig.diffY = 0
			console.log('TOUCHEND', e)
			console.log('APPCONFIG', window.appConfig)
		})

      };

      spawnBox = (function () {
        var box_geometry = new THREE.BoxGeometry(4, 4, 4),
          sphere_geometry = new THREE.SphereGeometry(1, 16, 16),
          handleCollision = function (
            collided_with,
            linearVelocity,
            angularVelocity
          ) {
            switch (++this.collisions) {
              case 1:
                this.material.color.setHex(0xcc8855);
                break;

              case 2:
                this.material.color.setHex(0xbb9955);
                break;

              case 3:
                this.material.color.setHex(0xaaaa55);
                break;

              case 4:
                this.material.color.setHex(0x99bb55);
                break;

              case 5:
                this.material.color.setHex(0x88cc55);
                break;

              case 6:
                this.material.color.setHex(0x77dd55);
                break;
            }
          },
          createBox = function () {
            var box, material;

            material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial(),
              // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
              0.6, // medium friction
              0.3 // low restitution
            );

            //material = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) });

            box = new Physijs.BoxMesh(box_geometry, material);
            box.collisions = 0;

            box.position.set(
              Math.random() * 15 - 7.5,
              25,
              Math.random() * 15 - 7.5
            );

            box.rotation.set(
              Math.random() * Math.PI,
              Math.random() * Math.PI,
              Math.random() * Math.PI
            );

            box.castShadow = true;
            box.addEventListener("collision", handleCollision);
            box.addEventListener("ready", spawnBox);
            scene.add(box);
          };

        let createSphere = function () {
          var sphere, material;

          material = Physijs.createMaterial(
            new THREE.MeshPhongMaterial(),
            0.5, // medium friction
            3 // low restitution
          );
          // material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
          // material.map.repeat.set( .5, .5 );

          //material = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) });

          sphere = new Physijs.SphereMesh(sphere_geometry, material);
          sphere.collisions = 0;

          sphere.position.set(
            Math.random() * 15 - 7.5,
            25,
            0
          );

          sphere.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );

          sphere.castShadow = true;
		  sphere.addEventListener("collision", handleCollision);
		  sphere.gameName = 'SPHERE0'
          scene.add(sphere);
        };
        return () => {
		  createSphere();

		  const glassMesh0 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(50, 50, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: new THREE.Color('blue'),
              opacity: .05,
              transparent: true,
            }),
            /*mass*/ 0
		  );

		  const glassMesh1 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(50, 50, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: new THREE.Color('red'),
              opacity: .05,
              transparent: true,
            }),
            /*mass*/ 0
		  );

		  glassMesh0.position.z = -5
		  glassMesh1.position.z = 5

          scene.add(glassMesh0);
          scene.add(glassMesh1);
		

        };
        // return function() {
        // 	setTimeout( createBox, 2000 );
        // 	setTimeout( createSphere, 1500 );
        // };
      })();

      render = function () {
        // scene.children.forEach((m, mi) => {
        // 	if(mi > 3) {
        // 		console.log(m, mi)
        // 		m.position.z = 0
        // 	}
		// })
		if(window.appConfig.touchStart === true && window.appConfig.touchEnd === false) {
			console.log('ACTIVE!!!')
			scene.children[6].setLinearVelocity(new THREE.Vector3(window.appConfig.diffX, 0, window.appConfig.diffY))
			console.log(scene.children[6])
		}
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        render_stats.update();
      };

      window.onload = initScene;
    </script>
  </head>

  <body>
    <div id="viewport"></div>
  </body>
</html>
