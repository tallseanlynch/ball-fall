<!DOCTYPE html>

<html>
  <head>
    <title>Collisions - Physijs</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
      }
      html { touch-action:none; }
    </style>

    <script type="text/javascript" src="js/ammo.js"></script>
    <script type="text/javascript" src="js/three-121.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="js/physi.js"></script>
    <script type="text/javascript" src="js/physijs_worker.js"></script>
    <script type="text/javascript" src="js/THREEOrbitControls.js"></script>

    <script type="text/javascript">
      "use strict";

      Physijs.scripts.worker = "js/physijs_worker.js";
      Physijs.scripts.ammo = "ammo.js";

      const basicColors = [
        new THREE.Color(0xfff1e3),
        new THREE.Color(0xffd5c9),
        new THREE.Color(0xffa6bb),
        new THREE.Color(0xff757f),
        new THREE.Color(0x159294),
      ];

      const getRandomColor = () => {
        // console.log(basicColors[Math.floor(Math.round() * basicColors.length)])
        // debugger
        return basicColors[Math.floor(Math.random() * basicColors.length)];
      };

      var initScene,
        render,
        _boxes = [],
        spawnBox,
        loader,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground_material,
        ground,
        light,
        camera,
        orbitControls;

      initScene = function () {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById("viewport").appendChild(renderer.domElement);

        render_stats = new Stats();
        render_stats.domElement.style.position = "absolute";
        render_stats.domElement.style.top = "0px";
        render_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(render_stats.domElement);

        physics_stats = new Stats();
        physics_stats.domElement.style.position = "absolute";
        physics_stats.domElement.style.top = "50px";
        physics_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(physics_stats.domElement);

        scene = new Physijs.Scene();

        scene.background = getRandomColor();
        scene.setGravity(new THREE.Vector3(0, -10, 0));

        scene.addEventListener("update", function () {
          scene.simulate(undefined, 1);
          physics_stats.update();
        });

        const skyColor = getRandomColor();
        const groundColor = getRandomColor();
        const hemisphereLight = new THREE.HemisphereLight(
          skyColor,
          groundColor,
          0.75
        );
        scene.add(hemisphereLight);

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(0, 25, 100);
        camera.lookAt(scene.position);
        scene.add(camera);

        // Light
        light = new THREE.SpotLight(0xffffff);
        light.position.set(20, 80, 15);
        light.target.position.copy(scene.position);
        light.castShadow = true;
        light.shadowCameraLeft = -60;
        light.shadowCameraTop = -60;
        light.shadowCameraRight = 60;
        light.shadowCameraBottom = 60;
        light.shadowCameraNear = 20;
        light.shadowCameraFar = 200;
        light.shadowBias = -0.0001;
        light.shadowMapWidth = light.shadowMapHeight = 2048;
        light.shadowDarkness = 0.7;
        scene.add(light);

        const pointLight0 = new THREE.PointLight(getRandomColor(), 1);
        pointLight0.gameName = "POINTLIGHT0";
        pointLight0.power = 5;
        pointLight0.decay = 1;
        pointLight0.distance = 5;
        scene.add(pointLight0);

        // LFO
        const lfoPositive = (t = 1000) => {
          let lfoValue = (0.5 + 0.5 * Math.cos(Date.now() / t)) * 1;
          return lfoValue;
        };

        const lfo = (t = 1000) => {
          return (0.5 - lfoPositive(t)) * 2;
        };

        // Orbit Controls
        // orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        // orbitControls.enableRotate = false;

        //resize event handler
        function onWindowResize(event) {
          // remember these initial values
          var tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
          var windowHeight = window.innerHeight;
          camera.aspect = window.innerWidth / window.innerHeight;

          // adjust the FOV
          camera.fov =
            (360 / Math.PI) *
            Math.atan(tanFOV * (window.innerHeight / windowHeight));

          camera.updateProjectionMatrix();
          camera.lookAt(scene.position);

          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.render(scene, camera);
        }
        onWindowResize();
        window.addEventListener("resize", onWindowResize, false);

        // Loader

        const listener = new THREE.AudioListener();
          camera.add( listener );

        // create a global audio source
        const sound = new THREE.Audio( listener );

        // load a sound and set it as the Audio object's buffer
        const audioLoader = new THREE.AudioLoader();

        const startAudio = (source) => {
          audioLoader.load( 'sounds/ball-fall-sounds 19-3-Audio 1.mp3', function( buffer ) {
            sound.setBuffer( buffer );
            sound.setLoop( true );
            sound.setVolume( 0.25 );
            sound.play();
          });
        }

        loader = new THREE.TextureLoader();

        // Ground
        // ground_material = Physijs.createMaterial(
        //   new THREE.MeshLambertMaterial({
        //     map: loader.load("images/rocks.jpg"),
        //   }),
        //   0.8, // high friction
        //   0.3 // low restitution
        // );
        // ground_material.map.wrapS = ground_material.map.wrapT =
        //   THREE.RepeatWrapping;
        // ground_material.map.repeat.set(3, 3);

        // ground = new Physijs.BoxMesh(
        //   new THREE.BoxGeometry(100, 1, 100),
        //   ground_material,
        //   0 // mass
        // );

        let features = [];

        const groundBox = new Physijs.BoxMesh(
          new THREE.BoxGeometry(10, 1, 10),
          new THREE.MeshPhongMaterial({ color: getRandomColor() }),
          0 // mass
        );
        groundBox.position.y = randomNumber(5);
        groundBox.position.x = randomNumber(5);
        groundBox.position.__dirtyPosition = true;
        groundBox.setLinearVelocity(new THREE.Vector3(0, 0, 0));
        groundBox.setAngularVelocity(new THREE.Vector3(0, 0, 0));
        groundBox.castShadow = true;
        groundBox.receiveShadow = true;
        groundBox.rotation.x = Math.random() * 2 * Math.PI;
        groundBox.rotation.y = Math.random() * 2 * Math.PI;
        // groundBox.rotation.z = Math.random() * 2 * Math.PI

        const groundBox1 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(30, 1, 10),
          new THREE.MeshPhongMaterial({ color: getRandomColor() }),
          0 // mass
        );
        function randomNumber(n) {
          return Math.round(Math.random() * n);
        }
        groundBox1.position.y = randomNumber(10);
        groundBox1.position.x = randomNumber(20);
        groundBox1.position.z = randomNumber(-10);
        groundBox1.position.__dirtyPosition = true;
        groundBox1.setLinearVelocity(new THREE.Vector3(0, 0, 0));
        groundBox1.setAngularVelocity(new THREE.Vector3(0, 0, 0));
        groundBox1.castShadow = true;
        groundBox1.receiveShadow = true;
        groundBox1.rotation.x = Math.random() * 2 * Math.PI;
        groundBox1.rotation.y = Math.random() * 2 * Math.PI;
        // groundBox1.rotation.z = Math.random() * 2 * Math.PI

        const groundBox2 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(30, 1, 10),
          new THREE.MeshPhongMaterial({ color: getRandomColor() }),
          0 // mass
        );
        groundBox2.position.x = 0;
        groundBox2.position.y = randomNumber(-15);
        groundBox2.position.__dirtyPosition = true;
        groundBox2.setLinearVelocity(new THREE.Vector3(0, 0, 0));
        groundBox2.setAngularVelocity(new THREE.Vector3(0, 0, 0));
        groundBox2.castShadow = true;
        groundBox2.receiveShadow = true;
        groundBox2.rotation.x = Math.random() * 2 * Math.PI;
        groundBox2.rotation.y = Math.random() * 2 * Math.PI;
        groundBox2.name = "GROUNDBOX2"
        groundBox2.featureType = "BOX"
        
        // groundBox2.rotation.z = Math.random() * 2 * Math.PI

        // ground.receiveShadow = true;
        // scene.add(ground);
        // scene.add(groundBox);
        // scene.add(groundBox1);
        scene.add(groundBox2);
        spawnBox();

        requestAnimationFrame(render);
        scene.simulate();
        const clickRay = new THREE.Raycaster()

        window.appConfig = {
          touchStart: false,
          touchEnd: false,
          currentX: 0,
          currentY: 0,
          prevX: 0,
          prevY: 0,
          diffX: 0,
          diffY: 0,
          start: false,
          pause: false,
          startAudio: startAudio,
          audioLoader: audioLoader,
          soundSource: sound
        };

        document.addEventListener("touchstart", (e) => {
          window.appConfig.touchEnd = false;
          window.appConfig.touchStart = true;
          window.appConfig.currentX = e.touches[0].clientX;
          window.appConfig.currentY = e.touches[0].clientY;

          window.appConfig.prevX = e.touches[0].clientX;
          window.appConfig.prevY = e.touches[0].clientY;
          window.appConfig.diffX =
            window.appConfig.currentX - window.appConfig.prevX;
          window.appConfig.diffY =
            window.appConfig.currentY - window.appConfig.prevY;
          console.log("TOUCHSTART", e);
          console.log("APPCONFIG", window.appConfig);
        });
        // document.addEventListener('mousemove', (e) => {
        // 	console.log('MOUSEMOVE', e.clientX, e.clientY)
        // })
        document.body.addEventListener(
          "touchmove",
          (e) => {
            window.appConfig.prevX = window.appConfig.currentX;
            window.appConfig.prevY = window.appConfig.currentY;
            window.appConfig.currentX = e.touches[0].clientX;
            window.appConfig.currentY = e.touches[0].clientY;
            window.appConfig.diffX =
              e.touches[0].clientX - window.appConfig.prevX;
            window.appConfig.diffY =
              e.touches[0].clientY - window.appConfig.prevY;
            console.log(
              "TOUCHMOVE",
              e.touches[0].clientX,
              e.touches[0].clientY
            );
            console.log("APPCONFIG", window.appConfig);
            console.log(window.appConfig.diffX, window.appConfig.diffY);
            e.preventDefault()
          },
          true
        );
        document.addEventListener("touchend", (e) => {
          window.appConfig.touchEnd = true;
          window.appConfig.touchStart = false;
          window.appConfig.currentX = 0;
          window.appConfig.currentY = 0;
          window.appConfig.diffX = 0;
          window.appConfig.diffY = 0;
          console.log("TOUCHEND", e);
          console.log("APPCONFIG", window.appConfig);
        });
        document.addEventListener("click", (e) => {
          e.preventDefault()
          console.log("CLICK", e);
          const normalized = new THREE.Vector2(e.clientX, e.clientY)
          clickRay.setFromCamera(normalized.normalize(), camera)
          
          console.log(
            clickRay.intersectObject(
              scene.children.find((obj) => obj.name === 'stage').children.find((obj) => obj.gameName === 'FRONTGLASS')
            )
          )
          console.log("APPCONFIG", window.appConfig);
        });
      };

      spawnBox = (function () {
        var box_geometry = new THREE.BoxGeometry(4, 4, 4),
          sphere_geometry = new THREE.SphereGeometry(1, 16, 16),
          handleCollision = function (
            collided_with,
            linearVelocity,
            angularVelocity
          ) {
            console.log("collision");
            console.log("collided_with", collided_with)
            if(collided_with.featureType === 'BOX') {
              // debugger
              // collided_with.children[0].play()
              // const groundBox2Audio = new THREE.PositionalAudio( window.appConfig.listener2 );

              // window.appConfig.audioLoader.load( 'sounds/ball-fall-sounds 19-3-Audio 1.mp3', function( buffer ) {
              //   window.appConfig.soundSource2.setBuffer( buffer );
              //   window.appConfig.soundSource2.setBuffer( buffer );
              //   window.appConfig.soundSource2.setVolume( 0.99 );
              // });

              switch (++this.collisions%6) {
                case 1:
                  window.appConfig.soundSource.stop()
                  window.appConfig.audioLoader.load( 'sounds/ball-fall-sounds 1-Audio.mp3', function( buffer ) {
                    window.appConfig.soundSource.setBuffer( buffer );
                    // sound.setLoop( true );
                    window.appConfig.soundSource.setVolume( 0.25 );
                    window.appConfig.soundSource.play();
                  });
                  break;

                case 2:
                  window.appConfig.soundSource.stop()
                  window.appConfig.audioLoader.load( 'sounds/ball-fall-sounds 2-3-Audio 1.mp3', function( buffer ) {
                    window.appConfig.soundSource.setBuffer( buffer );
                    // sound.setLoop( true );
                    window.appConfig.soundSource.setVolume( 0.25 );
                    window.appConfig.soundSource.play();
                  });
                  break;

                case 3:
                  window.appConfig.soundSource.stop()
                  window.appConfig.audioLoader.load( 'sounds/ball-fall-sounds 3-3-Audio 1.mp3', function( buffer ) {
                    window.appConfig.soundSource.setBuffer( buffer );
                    // sound.setLoop( true );
                    window.appConfig.soundSource.setVolume( 0.25 );
                    window.appConfig.soundSource.play();
                  });
                  break;

                case 4:
                  window.appConfig.soundSource.stop()
                  window.appConfig.audioLoader.load( 'sounds/ball-fall-sounds 4-3-Audio 1.mp3', function( buffer ) {
                    window.appConfig.soundSource.setBuffer( buffer );
                    // sound.setLoop( true );
                    window.appConfig.soundSource.setVolume( 0.25 );
                    window.appConfig.soundSource.play();
                  });
                  break;

                case 5:
                  window.appConfig.soundSource.stop()
                  window.appConfig.audioLoader.load( 'sounds/ball-fall-sounds 5-3-Audio 1.mp3', function( buffer ) {
                    window.appConfig.soundSource.setBuffer( buffer );
                    // sound.setLoop( true );
                    window.appConfig.soundSource.setVolume( 0.25 );
                    window.appConfig.soundSource.play();
                  });
                  break;

                case 6:
                  window.appConfig.soundSource.stop()
                  window.appConfig.audioLoader.load( 'sounds/ball-fall-sounds 6-3-Audio 1.mp3', function( buffer ) {
                    window.appConfig.soundSource.setBuffer( buffer );
                    // sound.setLoop( true );
                    window.appConfig.soundSource.setVolume( 0.25 );
                    window.appConfig.soundSource.play();
                  });
                  break;
              }

              console.log('AFTERPLAY')
            }

          },
          createBox = function () {
            var box, material;

            material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial(),
              // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
              0.6, // medium friction
              0.3 // low restitution
            );

            //material = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) });

            box = new Physijs.BoxMesh(box_geometry, material);
            box.collisions = 0;

            box.position.set(
              Math.random() * 15 - 7.5,
              25,
              Math.random() * 15 - 7.5
            );

            box.rotation.set(
              Math.random() * Math.PI,
              Math.random() * Math.PI,
              Math.random() * Math.PI
            );

            box.castShadow = true;
            // box.addEventListener("collision", handleCollision);
            box.addEventListener("ready", spawnBox);
            scene.add(box);
          };

        let createSphere = function () {
          var sphere, material;

          material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
              color: getRandomColor()
              // envMap: scene.background,
              // combine: THREE.MixOperation,
              // reflectivity: 0.1,
              // transparent: true,
              // opacity: 0.98
            }),
            0.5, // medium friction
            3 // low restitution
          );
          // material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
          // material.map.repeat.set( .5, .5 );

          //material = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) });

          sphere = new Physijs.SphereMesh(sphere_geometry, material);
          sphere.collisions = 0;

          sphere.position.set(0, 50, 0);

          sphere.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );

          sphere.castShadow = true;
          sphere.addEventListener("collision", handleCollision);
          sphere.gameName = "SPHERE0";
          scene.add(sphere);
        };
        return () => {
          createSphere();

          const glassMesh0 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(25, 375, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: new THREE.Color("blue"),
              opacity: 0.5,
              transparent: true
            }),
            /*mass*/ 0
          );
          glassMesh0.gameName = "FRONTGLASS"
          glassMesh0.name = "glassMesh0"

          const glassMesh1 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(25, 375, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: new THREE.Color("red"),
              opacity: 0.5,
              transparent: true,
              name: "glassMesh1",
            }),
            /*mass*/ 0
          );
          const glassMesh2 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(3, 375, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: new THREE.Color("green"),
              opacity: 0.5,
              transparent: true,
              name: "glassMesh2",
            }),
            /*mass*/ 0
          );

          const glassMesh3 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(3, 375, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: new THREE.Color("yellow"),
              opacity: 0.5,
              transparent: true,
              name: "glassMesh3",
            }),
            /*mass*/ 0
          );
          const stageFloor = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(25, 1, 3),
            /*material*/ new THREE.MeshBasicMaterial({
              color: new THREE.Color("purple"),
              opacity: 0.5,
              transparent: true
            }),
            /*mass*/ 0
          );

          stageFloor.name = "stageFloor"

          const stage = new Physijs.BoxMesh(
            new THREE.Geometry(),
            /*material*/ new THREE.MeshBasicMaterial(),
            /*mass*/ 0
          );
          stage.name = "stage";
          stage.position.y = -140;

          glassMesh0.position.z = -1.5;
          glassMesh1.position.z = 1.5;
          glassMesh2.position.x = -12.5;
          glassMesh2.rotation.y = Math.PI * 0.5;
          glassMesh3.position.x = 12.5;
          glassMesh3.rotation.y = Math.PI * -0.5;
          stageFloor.position.y = -187;

          stage.add(glassMesh0);
          stage.add(glassMesh1);
          stage.add(glassMesh2);
          stage.add(glassMesh3);
          stage.add(stageFloor);
          scene.add(stage);
        };
        // return function() {
        // 	setTimeout( createBox, 2000 );
        // 	setTimeout( createSphere, 1500 );
        // };
      })();

      // let hasRendered = false

      render = function () {
        // scene.children.forEach((m, mi) => {
        // 	if(mi > 3) {
        // 		console.log(m, mi)
        // 		m.position.z = 0
        // 	}
        // })
        const sphere = scene.children.find((obj) => obj.gameName === "SPHERE0");
        const stage = scene.children.find((obj) => obj.name === "stage");

        if(window.appConfig.start === false || window.appConfig.pause === true) {
          if(window.appConfig.start === false) {
            sphere.position.set(0, 50, 0);
          }
          scene.children
            .find((obj) => obj.gameName === "SPHERE0")
            .setLinearVelocity(
              new THREE.Vector3(
                0,
                0,
                0
              )
            );
        } else {
          if (
            window.appConfig.touchStart === true &&
            window.appConfig.touchEnd === false
          ) {
            console.log("ACTIVE!!!");
            const scaleV = 0.5;
            scene.children
              .find((obj) => obj.gameName === "SPHERE0")
              .setLinearVelocity(
                new THREE.Vector3(
                  window.appConfig.diffX * scaleV,
                  window.appConfig.diffY * -scaleV,
                  0
                )
              );
          }
        }

        const spherePosition = scene.children.find(
          (obj) => obj.gameName === "SPHERE0"
        ).position;
        scene.children
          .find((obj) => obj.gameName === "POINTLIGHT0")
          .position.set(
            spherePosition.x,
            spherePosition.y + 1,
            spherePosition.z
          );

        const stageFloor = stage.children.find(
          (obj) => obj.name === "stageFloor"
        );
        const compareVector = new THREE.Vector3();
        const distanceSphereToStageFloor = compareVector
          .subVectors(
            new THREE.Vector3().setFromMatrixPosition(sphere.matrixWorld),
            new THREE.Vector3().setFromMatrixPosition(stageFloor.matrixWorld)
          )
          .length();
        if (distanceSphereToStageFloor > 50) {
          camera.position.y = sphere.position.y;
        }

        requestAnimationFrame(render);
        renderer.render(scene, camera);
        render_stats.update();
      };

      const start = () => {
        window.appConfig.start = true
        window.appConfig.startAudio()
        document.querySelector('#start-button').classList.add('hide')
      }

      const pause = () => {
        window.appConfig.pause = !window.appConfig.pause
      }

      window.onload = initScene;
    </script>
    <style>
      #start-button {
        position:fixed;
        left:40%;
        top:50%;
        padding: 10px 30px;
        border: 3px solid black;
      }
      #pause-button {
        position:fixed;
        left:3%;
        bottom:3%;
        padding: 10px 30px;
        border: 3px solid black;
      }
      .hide {
        display: none;
        visibility: hidden;
      }

    </style>
  </head>

  <body>
    <div id="viewport"></div>
    <button id="start-button" onClick="start()">Start</button>
    <button id="pause-button" onClick="pause()">Pause</button>    
  </body>
</html>
