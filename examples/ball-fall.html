<!DOCTYPE html>

<html>
  <head>
    <title>Ball Fall</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
      }
      html {
        touch-action: none;
      }
      /* body {
        background: rgb(2, 0, 36);
        background: linear-gradient(
          180deg,
          rgba(2, 0, 36, 0) 0%,
          rgba(121, 9, 117, 1) 0%,
          rgba(0, 212, 255, 1) 33%,
          rgba(252, 231, 183, 1) 66%
          rgba(2, 0, 36, 0) 100%
        );
      } */
    </style>

    <script type="text/javascript" src="js/ammo.js"></script>
    <script type="text/javascript" src="js/three-121.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="js/physi.js"></script>
    <script type="text/javascript" src="js/physijs_worker.js"></script>
    <script type="text/javascript" src="js/THREEOrbitControls.js"></script>
    <script type="text/javascript" src="js/easytimer.js"></script>
    <script type="text/javascript" src="js/howler.min.js"></script>
    <script src="https://unpkg.com/three@0.112.0/examples/js/loaders/GLTFLoader.js"></script>
    <script type="text/javascript">
      "use strict";

      var backgroundMusic0 = new Howl({
        src: ["sounds/BALL FALL jingle flat 1.mp3"],
        autoPlay: true,
        loop: false,
        onend: () => {
          console.log("finished 1");
        },
      });
      backgroundMusic0.volume(0.1);

      var howlSound0 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a1.mp3"],
        onstart: () => {
          console.log("started 0");
        },
        onend: () => {
          console.log("finished 0");
        },
      });

      var howlSound1 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a2.mp3"],
        onstart: () => {
          console.log("started 1");
        },
        onend: () => {
          console.log("finished 1");
        },
      });

      var howlSound2 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a3.mp3"],
        onstart: () => {
          console.log("started 2");
        },
        onend: () => {
          console.log("finished 2");
        },
      });

      var howlSound3 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a4.mp3"],
        onstart: () => {
          console.log("started 3");
        },
        onend: () => {
          console.log("finished 3");
        },
      });

      var howlSound4 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a5.mp3"],
        onstart: () => {
          console.log("started 4");
        },
        onend: () => {
          console.log("finished 4");
        },
      });

      var howlSound5 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a6.mp3"],
        onstart: () => {
          console.log("started 5");
        },
        onend: () => {
          console.log("finished 5");
        },
      });

      var howlSound6 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a7.mp3"],
        onstart: () => {
          console.log("started 6");
        },
        onend: () => {
          console.log("finished 6");
        },
      });

      var howlSound7 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a8.mp3"],
        onstart: () => {
          console.log("started 7");
        },
        onend: () => {
          console.log("finished 7");
        },
      });

      backgroundMusic0.play();
      Physijs.scripts.worker = "js/physijs_worker.js";
      Physijs.scripts.ammo = "ammo.js";

      const basicColors = [
        new THREE.Color(0xfff1e3),
        new THREE.Color(0xffd5c9),
        new THREE.Color(0xffa6bb),
        new THREE.Color(0xff757f),
        new THREE.Color(0x159294),
      ];

      let adjustCamera = 20;

      const getRandomColor = () => {
        return basicColors[Math.floor(Math.random() * basicColors.length)];
      };

      var initScene,
        render,
        _boxes = [],
        spawnBox,
        loader,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground_material,
        ground,
        light,
        camera,
        orbitControls;

      initScene = function () {
        window.appConfig = {};
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById("viewport").appendChild(renderer.domElement);

        render_stats = new Stats();
        render_stats.domElement.style.position = "absolute";
        render_stats.domElement.style.top = "0px";
        render_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(render_stats.domElement);

        physics_stats = new Stats();
        physics_stats.domElement.style.position = "absolute";
        physics_stats.domElement.style.top = "50px";
        physics_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(physics_stats.domElement);

        scene = new Physijs.Scene();

        // scene.background = getRandomColor();
        scene.setGravity(new THREE.Vector3(0, -10, 0));

        scene.addEventListener("update", function () {
          scene.simulate(undefined, 1);
          physics_stats.update();
        });

        const skyColor = getRandomColor();
        const groundColor = getRandomColor();
        const hemisphereLight = new THREE.HemisphereLight(
          skyColor,
          groundColor,
          0.75
        );
        scene.add(hemisphereLight);

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );

        adjustCamera = 20;
        camera.position.set(0, 10, 10);
        // camera.lookAt(new THREE.Vector3(0, adjustCamera, 0));
        camera.lookAt(new THREE.Vector3(0, 10, 0));
        // sphere.position.set(0, 10, 0);
        // camera.lookAt(new THREE.Vector3(sphere.position.x, sphere.position.y + 10, sphere.position.z));
        // camera.lookAt(scene.position);
        scene.add(camera);

        // const cameraPositionTimer = new easytimer.Timer()

        // cameraPositionTimer.start({countdown: true, startValues: {seconds: 1}})
        // setTimeout(() => {
        //   console.log(cameraPositionTimer.getTotalTimeValues().seconds, cameraPositionTimer.getTotalTimeValues().seconds)
        // }, 5000)

        // Light
        light = new THREE.SpotLight(0xffffff);
        light.position.set(20, 80, 15);
        light.target.position.copy(scene.position);
        light.castShadow = true;
        light.shadowCameraLeft = -60;
        light.shadowCameraTop = -60;
        light.shadowCameraRight = 60;
        light.shadowCameraBottom = 60;
        light.shadowCameraNear = 20;
        light.shadowCameraFar = 200;
        light.shadowBias = -0.0001;
        light.shadowMapWidth = light.shadowMapHeight = 2048;
        light.shadowDarkness = 0.7;
        scene.add(light);

        const pointLight0 = new THREE.PointLight(getRandomColor(), 1);
        pointLight0.gameName = "POINTLIGHT0";
        pointLight0.power = 5;
        pointLight0.decay = 1;
        pointLight0.distance = 5;
        scene.add(pointLight0);

        // LFO
        const lfoPositive = (t = 1000) => {
          let lfoValue = (0.5 + 0.5 * Math.cos(Date.now() / t)) * 1;
          return lfoValue;
        };

        const lfo = (t = 1000) => {
          return (0.5 - lfoPositive(t)) * 2;
        };

        // Orbit Controls
        // orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        // orbitControls.enabled = false;

        //resize event handler
        function onWindowResize(event) {
          //put the start button right in the middle!
          centerElement({ id: "start-button", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "level-select", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "report", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "pause-menu", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "title", offsetTop: -200, offsetLeft: 0 });
          centerElement({ id: "start-menu", offsetTop: 200, offsetLeft: 0 });
          // remember these initial values
          var tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
          var windowHeight = window.innerHeight;
          camera.aspect = window.innerWidth / window.innerHeight;

          // adjust the FOV
          camera.fov =
            (360 / Math.PI) *
            Math.atan(tanFOV * (window.innerHeight / windowHeight));

          camera.updateProjectionMatrix();
          // camera.lookAt(scene.position);

          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.render(scene, camera);
        }
        onWindowResize();
        window.addEventListener("resize", onWindowResize, false);

        loader = new THREE.TextureLoader();

        let level = 25;
        window.appConfig.level = level;
        let score = {
          coins: 0,
        };
        window.appConfig.score = score;

        const featureTypes = {
          ramp: [],
          cone: [],
          icosahedron: [],
          tetrahedron: [],
          torus: [],
          disc: [],
        };

        window.appConfig.featureTypes = featureTypes;
        const defaultYLanes = [16, 8, 0, -8, -16]; // to copy, splice, and then populate openSpots
        const openSpots = [];
        window.appConfig.openSpots = openSpots;
        const coins = [];
        window.appConfig.coins = coins;

        const cone = () => {
          const obj = new Physijs.ConeMesh(
            new THREE.CylinderGeometry(0, 4.75, 3.75, 32),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({ color: getRandomColor() }),
              // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          zone.obj = obj;
          obj.position.x = xPosition + 2.5;
          obj.position.y = yPosition - 12;
          obj.position.z = 0;
          obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
          obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
          obj.castShadow = true;
          obj.receiveShadow = true;
          obj.rotation.x = Math.random() * 2 * Math.PI;
          obj.rotation.y = Math.random() * 2 * Math.PI;
          obj.rotation.z = Math.random() * 2 * Math.PI;
          obj.featureType = "CONE";
          scene.add(obj);
        } 
                
        const icosahedron = () => {
          const obj = new Physijs.ConvexMesh(
            new THREE.IcosahedronGeometry(Math.random() * 3 + 1, 0),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({ color: getRandomColor() }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          zone.obj = obj;

          obj.position.x = xPosition + 2.5;
          obj.position.y = yPosition - 12;
          obj.position.z = 0;
          obj.position.__dirtyPosition = true;
          obj.rotation.__dirtyRotation = true;
          obj.__dirtyPosition = true;
          obj.__dirtyRotation = true;
          obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
          obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
          obj.castShadow = true;
          obj.receiveShadow = true;
          obj.rotation.x = Math.random() * 2 * Math.PI;
          obj.rotation.y = Math.random() * 2 * Math.PI;
          obj.rotation.z = Math.random() * 2 * Math.PI;
          obj.featureType = "ICOSAHEDRON";
          scene.add(obj);
        } 

        const disc = () => {
          const radius = Math.random() * 3 + 1;
          const obj = new Physijs.CylinderMesh(
            new THREE.CylinderGeometry(
              radius,
              radius,
              Math.random() * 3,
              Math.ceil(Math.random() * 16 + 2)
            ),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({ color: getRandomColor() }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          zone.obj = obj;
          obj.position.x = xPosition + 2.5;
          obj.position.y = yPosition - 12;
          obj.position.z = 0;
          obj.position.__dirtyPosition = true;
          obj.rotation.__dirtyRotation = true;
          obj.__dirtyPosition = true;
          obj.__dirtyRotation = true;
          obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
          obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
          obj.castShadow = true;
          obj.receiveShadow = true;
          obj.rotation.x = Math.random() * 2 * Math.PI;
          obj.rotation.y = Math.random() * 2 * Math.PI;
          obj.rotation.z = Math.random() * 2 * Math.PI;
          obj.featureType = "DISC";
          scene.add(obj);
        } 
                
        const tetrahedron = () => {
          const radius = Math.random() * 3 + 1;
          const obj = new Physijs.ConvexMesh(
            new THREE.TetrahedronGeometry(Math.random() * 3 + 2),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({ color: getRandomColor() }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          obj.position.x = xPosition + 2.5;
          obj.position.y = yPosition - 12;
          obj.position.z = 0;
          obj.position.__dirtyPosition = true;
          obj.rotation.__dirtyRotation = true;
          obj.__dirtyPosition = true;
          obj.__dirtyRotation = true;
          obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
          obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
          obj.castShadow = true;
          obj.receiveShadow = true;
          obj.rotation.x = Math.random() * 2 * Math.PI;
          obj.rotation.y = Math.random() * 2 * Math.PI;
          obj.rotation.z = Math.random() * 2 * Math.PI;
          obj.featureType = "TETRAHEDRON";
          scene.add(obj);
        } 

        const torus = () => {
          const radiusMod = Math.random() * 3 + 1;
          const obj = new Physijs.ConvexMesh(
            new THREE.TorusGeometry(
              Math.random() + 1,
              0.2,
              6,
              Math.random() > 0.5 ? 4 : 5
            ),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({ color: getRandomColor() }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          obj.position.x = xPosition + 2.5;
          obj.position.y = yPosition - 12;
          obj.position.z = 0;
          obj.position.__dirtyPosition = true;
          obj.rotation.__dirtyRotation = true;
          obj.__dirtyPosition = true;
          obj.__dirtyRotation = true;
          obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
          obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
          obj.castShadow = true;
          obj.receiveShadow = true;
          obj.rotation.x = Math.random() * 2 * Math.PI;
          obj.rotation.y = Math.random() * 2 * Math.PI;
          obj.rotation.z = Math.random() * 2 * Math.PI;
          obj.featureType = "TORUS";
          scene.add(obj);
        }
      

        const createBeam = (config) => {
          const beam0 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(10 * config.s, 2, 2),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({ color: config.color ? config.color : 0xffffff }),
            0.6, // medium friction
            0.3 // low restitution
          ),
          0 // mass
          );
          const beam0cap0 = new Physijs.BoxMesh(
            new THREE.BoxGeometry(1.45, 2, 1.45),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({ color: config.color ? config.color : 0xffffff }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          const beam0cap1 = new Physijs.BoxMesh(
            new THREE.BoxGeometry(1.45, 2, 1.45),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({ color: config.color ? config.color : 0xffffff }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          beam0cap0.rotation.y = 0.25 * Math.PI;
          beam0cap0.position.x = -5 * config.s;
          beam0.add(beam0cap0);
          beam0cap1.rotation.y = 0.25 * Math.PI;
          beam0cap1.position.x = 5 * config.s;
          beam0.add(beam0cap1);
          beam0.position.set(config.p[0], config.p[1], config.p[2]);
          beam0.rotation.set(config.r[0], config.r[1], config.r[2]);
          return beam0;
        };


        const xAdj = -60
        const vAdj = -70
        const sAdj = 2

        const createStage0MainBeamStructure = (scale, scaleAdj = 0, name) => {
          const mainStructure = new Physijs.BoxMesh(
            new THREE.BoxGeometry(.01,.01,.01),
            new Physijs.createMaterial(
              new THREE.MeshPhongMaterial({transparent:true, opacity: 0}),
              0.6,
              0.3
            ),
            0
          )
          mainStructure.position.set(0,0,1.5)
          mainStructure.add(createBeam({p: [0 * scale, -8 * scale, -1], r: [0,0,0], s: (1 + scaleAdj) * scale}))
          mainStructure.add(createBeam({p: [-8 * scale, 0 * scale, -1], r: [0,0,.5 * Math.PI], s: (1 + scaleAdj) * scale}))
          mainStructure.add(createBeam({p: [8 * scale, 0 * scale, -1], r: [0,0,.5 * Math.PI], s: (1 + scaleAdj) * scale}))
          mainStructure.add(createBeam({p: [0 * scale, 8 * scale, -1], r: [0,0,0], s: (1 + scaleAdj) * scale}))
          mainStructure.name = name
          mainStructure.__dirtyPosition = true
          return mainStructure
        }

        const stage0MainBeamStructure = createStage0MainBeamStructure(2, 0, 'STAGE0MAINSTRUCTURE')
        scene.add(stage0MainBeamStructure)
        const stage0MainBeamStructure1 = createStage0MainBeamStructure(4, 0, 'STAGE0MAINSTRUCTURE1')
        scene.add(stage0MainBeamStructure1)
        const stage0MainBeamStructure2 = createStage0MainBeamStructure(8, .525, 'STAGE0MAINSTRUCTURE2')
        scene.add(stage0MainBeamStructure2)

        const stage0 = {
          beams: [
            createBeam({p: [-19.5,15,0], r: [0,0, .25 * Math.PI], s: 5}),
            createBeam({p: [19.5,15,0], r: [0,0, -.25 * Math.PI], s: 5}),
            createBeam({p: [-21.5,-22,0], r: [0,0, -.25 * Math.PI], s: 4.5}),
            createBeam({p: [21.5,-22,0], r: [0,0, .25 * Math.PI], s: 4.5}),
            createBeam({p: [0,-5,0], r: [0,0,0], s: 1}),
            createBeam({p: [-19.5,5+vAdj,0], r: [0,0, .25 * Math.PI], s: 2}),
            createBeam({p: [19.5,5+vAdj,0], r: [0,0, -.25 * Math.PI], s: 2}),
            createBeam({p: [-21.5,-22+vAdj,0], r: [0,0, -.25 * Math.PI], s: 2}),
            createBeam({p: [21.5,-22+vAdj,0], r: [0,0, .25 * Math.PI], s: 2}),
            createBeam({p: [0,-5+vAdj,0], r: [0,0,0], s: 1}),
            createBeam({p: [-19.5+xAdj,15,0], r: [0,0, .25 * Math.PI], s: 1}),
            createBeam({p: [19.5+xAdj,15,0], r: [0,0, -.25 * Math.PI], s: 1}),
            createBeam({p: [-21.5+xAdj,-22,0], r: [0,0, -.25 * Math.PI], s: 1}),
            createBeam({p: [21.5+xAdj,-22,0], r: [0,0, .25 * Math.PI], s: 1}),
            createBeam({p: [0+xAdj,-5,0], r: [0,0,0], s: 1}),
          ]
        }

        const crystal = (size = 0, p = {x: 0, y:0, z:0}) => {

          const tripleHex = 0x159294;
          const doubleHex = 0xffa6bb;
          const singleHex = 0xffd5c9;
          const tripleScale = 2;
          const doubleScale = 1.5;
          const singleScale = 1;
          const xScaleMod = 0.5;
          const yScaleMod = 1;
          const zScaleMod = 0.5;

          const crystalMaterialOptions = {
            color: 0x000000,
            emissive: 0xffffff,
            transparent: true,
            opacity: 0.85,
            shininess: 150,
            roughness: 0.2,
            metalness: 0.2,
          };

          const coin = new THREE.Mesh();
            const crystalTop = new THREE.Mesh(
              new THREE.CylinderGeometry(0, 1, 0.5, 6),
              new THREE.MeshPhongMaterial()
            );
            crystalTop.translateY(0.75);
            const crystalMiddle = new THREE.Mesh(
              new THREE.CylinderGeometry(1, 1, 1, 6),
              new THREE.MeshPhongMaterial()
            );

            const crystalBottom = new THREE.Mesh(
              new THREE.CylinderGeometry(1, 0, 0.5, 6),
              new THREE.MeshPhongMaterial()
            );
            crystalBottom.translateY(-0.75);
            coin.add(crystalTop);
            coin.add(crystalMiddle);
            coin.add(crystalBottom);
            coin.position.set(
              p.x,
              p.y,
              0
            );
            coin.featureType = "COIN";
            if(size === 0){
              coin.scale.set(
                  singleScale * xScaleMod,
                  singleScale * yScaleMod,
                  singleScale * zScaleMod
                );
                coin.coinType = "single";
                coin.coinValue = 1;
                coin.children.forEach((child) => {
                  child.material.color.setHex(singleHex);
                });
              
            }
            if(size === 1){
              coin.scale.set(
                  doubleScale * xScaleMod,
                  doubleScale * yScaleMod,
                  doubleScale * zScaleMod
                );
                coin.coinType = "double";
                coin.coinValue = 2;
                coin.children.forEach((child) => {
                  child.material.color.setHex(doubleHex);
                });
            }

            if(size === 2) {
              coin.scale.set(
                tripleScale * xScaleMod,
                tripleScale * yScaleMod,
                tripleScale * zScaleMod
              );
              coin.coinType = "triple";
              coin.coinValue = 3;
              coin.children.forEach((child) => {
                child.material.color.setHex(tripleHex);
              });
            }
            coins.push(coin)
            return coin
        }

        const createCrystalCross = (s, t = {x: 0, y: 0}, size=0) => {
          scene.add(crystal(size, {x: 0 * s + t.x, y:1 * s + t.y, z:0}))
          scene.add(crystal(size, {x: 0 * s + t.x, y:-1 * s + t.y, z:0}))
          scene.add(crystal(size, {x: -1 * s + t.x, y:0 * s + t.y, z:0}))
          scene.add(crystal(size, {x: 1 * s + t.x, y:0 * s + t.y, z:0}))
        }
        const createCrystalLine = (s, t = {x: 0, y: 0}, size=0, n, dir='x') => {
          let i = 0;
          for(i;i<n;i++){
            if(dir==='x') {
              scene.add(crystal(size, {x: i * (s) + t.x, y: t.y, z:0}))
            } else {
              scene.add(crystal(size, {x: t.x, y: i * s + t.y, z:0}))
            }
          }
        }

        createCrystalCross(5)
        createCrystalCross(10)
        createCrystalCross(5, {x: 20, y: 20}, 1)
        createCrystalCross(5, {x: -20, y: 20}, 1)
        createCrystalCross(5, {x: -20, y: -20}, 1)
        createCrystalCross(5, {x: 20, y: -20}, 1)
        createCrystalCross(3, {x: 55, y: 55}, 0)
        createCrystalCross(3, {x: 35, y: 55}, 0)
        createCrystalCross(3, {x: 35, y: 35}, 0)
        createCrystalCross(3, {x: 55, y: 35}, 0)
        createCrystalCross(3, {x: 55, y: -55}, 0)
        createCrystalCross(3, {x: 35, y: -55}, 0)
        createCrystalCross(3, {x: 35, y: -35}, 0)
        createCrystalCross(3, {x: 55, y: -35}, 0)
        createCrystalCross(3, {x: -55, y: -55}, 0)
        createCrystalCross(3, {x: -35, y: -55}, 0)
        createCrystalCross(3, {x: -35, y: -35}, 0)
        createCrystalCross(3, {x: -55, y: -35}, 0)
        createCrystalCross(3, {x: -55, y: 55}, 0)
        createCrystalCross(3, {x: -35, y: 55}, 0)
        createCrystalCross(3, {x: -35, y: 35}, 0)
        createCrystalCross(3, {x: -55, y: 35}, 0)
        createCrystalLine(10, {x:-47.5, y:-20}, 2, 5, 'y')
        createCrystalLine(5, {x:54.5, y:-22}, 1, 10, 'y')
        createCrystalLine(5, {x:40.5, y:-22.5}, 0, 10, 'y')
        createCrystalLine(10, {x:47.5, y:-20}, 2, 5, 'y')
        createCrystalLine(5, {x:-54.5, y:-22}, 1, 10, 'y')
        createCrystalLine(5, {x:-40.5, y:-22.5}, 0, 10, 'y')
        createCrystalLine(10, {x:-20, y:-47.5}, 2, 5, 'x')
        createCrystalLine(5, {x:-22.5, y:-40}, 1, 10, 'x')
        createCrystalLine(5, {x:-22.5, y:-54.5}, 0, 10, 'x')
        createCrystalLine(10, {x:-20, y:47.5}, 2, 5, 'x')
        createCrystalLine(5, {x:-22.5, y:40}, 1, 10, 'x')
        createCrystalLine(5, {x:-22.5, y:54.5}, 0, 10, 'x')

        spawnBox();

        requestAnimationFrame(render);
        scene.simulate();
        const clickRay = new THREE.Raycaster();

        const timer = new easytimer.Timer({ precision: "secondTenths" });
        timer.addEventListener("secondTenthsUpdated", function (e) {
          document.querySelector(
            "#timer"
          ).innerText = `${timer
            .getTimeValues()
            .toString(["minutes", "seconds", "secondTenths"])}`;
        });
        const results = {};
        window.appConfig = {
          ...window.appConfig,
          touchStart: false,
          touchEnd: false,
          currentX: 0,
          currentY: 0,
          prevX: 0,
          prevY: 0,
          diffX: 0,
          diffY: 0,
          start: false,
          pause: false,
          timer: timer,
          results: results,
          pause: false,
        };

        document.addEventListener("touchstart", (e) => {
          if (!window.appConfig.stageResultsBallZoom.userHasEnded) {
            window.appConfig.touchEnd = false;
            window.appConfig.touchStart = true;
            window.appConfig.currentX = e.touches[0].clientX;
            window.appConfig.currentY = e.touches[0].clientY;

            window.appConfig.prevX = e.touches[0].clientX;
            window.appConfig.prevY = e.touches[0].clientY;
            window.appConfig.diffX =
              window.appConfig.currentX - window.appConfig.prevX;
            window.appConfig.diffY =
              window.appConfig.currentY - window.appConfig.prevY;
            console.log("TOUCHSTART", e);
            console.log("APPCONFIG", window.appConfig);
          }
        });

        document.body.addEventListener(
          "touchmove",
          (e) => {
            if (!window.appConfig.stageResultsBallZoom.userHasEnded) {
              window.appConfig.prevX = window.appConfig.currentX;
              window.appConfig.prevY = window.appConfig.currentY;
              window.appConfig.currentX = e.touches[0].clientX;
              window.appConfig.currentY = e.touches[0].clientY;
              window.appConfig.diffX =
                e.touches[0].clientX - window.appConfig.prevX;
              window.appConfig.diffY =
                e.touches[0].clientY - window.appConfig.prevY;
              console.log(
                "TOUCHMOVE",
                e.touches[0].clientX,
                e.touches[0].clientY
              );
              console.log("APPCONFIG", window.appConfig);
              console.log(window.appConfig.diffX, window.appConfig.diffY);
              e.preventDefault();
            }
          },
          true
        );

        document.addEventListener("touchend", (e) => {
          if (!window.appConfig.stageResultsBallZoom.userHasEnded) {
            window.appConfig.touchEnd = true;
            window.appConfig.touchStart = false;
            window.appConfig.currentX = 0;
            window.appConfig.currentY = 0;
            window.appConfig.diffX = 0;
            window.appConfig.diffY = 0;
            console.log("TOUCHEND", e);
            console.log("APPCONFIG", window.appConfig);
          }
        });

        document.addEventListener("click", (e) => {
          e.preventDefault();
          console.log("CLICK", e);
          const normalized = new THREE.Vector2(e.clientX, e.clientY);
          clickRay.setFromCamera(normalized.normalize(), camera);

          console.log(
            clickRay.intersectObject(
              scene.children.find((obj) => obj.gameName === "FRONTGLASS")
            )
          );
          console.log("APPCONFIG", window.appConfig);
        });

        document.querySelector("#curtain").classList.add("opacity-0");
      };

      spawnBox = (function () {
        var box_geometry = new THREE.BoxGeometry(4, 4, 4),
          sphere_geometry = new THREE.SphereGeometry(1, 32, 32),
          handleCollision = function (
            collided_with,
            linearVelocity,
            angularVelocity
          ) {
            console.log("collision");
            console.log("collided_with", collided_with);
            if (collided_with.featureType === "TORUS") {
              window.appConfig.stageResultsBallZoom.userHasEnded = true;
              window.appConfig.timer.pause();
              window.appConfig.results[`stage${window.appConfig.level}`]
                ? (window.appConfig.results[
                    `stage${window.appConfig.level}`
                  ].finalTime = window.appConfig.timer
                    .getTimeValues()
                    .toString(["minutes", "seconds", "secondTenths"]))
                : (window.appConfig.results[
                    `stage${window.appConfig.level}`
                  ] = {
                    finalTime: window.appConfig.timer
                      .getTimeValues()
                      .toString(["minutes", "seconds", "secondTenths"]),
                  });
              //now performance report and start level transition
              console.dir(window.appConfig.results);
              document.querySelector("#report-time").innerText =
                window.appConfig.results[
                  `stage${window.appConfig.level}`
                ].finalTime;
              document.querySelector("#report-coins").innerText =
                window.appConfig.score.coins;
              document.querySelector("#report").classList.remove("hide");
              centerElement({ id: "report", offsetTop: 0, offsetLeft: 0 });
              document.querySelector("#pause-button").classList.add("hide");
              document.querySelector("#pause-button").disabled = true;
            }
            const suonousFeatureTypes = [
              "BOX",
              "ICOSAHEDRON",
              "SIDEGLASS",
              // "STAGEFLOOR",
              "TETRAHEDRON",
              "CONE",
              "DISC",
              "TORUS",
              "PLINKO",
              "COIN",
            ];
            if (suonousFeatureTypes.indexOf(collided_with.featureType) > -1) {
              switch (++this.collisions % 8) {
                case 1:
                  howlSound0.play();
                  break;

                case 2:
                  howlSound1.play();
                  break;

                case 3:
                  howlSound2.play();
                  break;

                case 4:
                  howlSound3.play();
                  break;

                case 5:
                  howlSound4.play();
                  break;

                case 6:
                  howlSound5.play();
                  break;

                case 7:
                  howlSound6.play();
                  break;

                case 8:
                  howlSound7.play();
                  break;
              }
              console.log("AFTERPLAY");
            }
          },
          createBox = function () {
            var box, material;

            material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial(),
              0.6, // medium friction
              0.3 // low restitution
            );
            box = new Physijs.BoxMesh(box_geometry, material);
            box.collisions = 0;

            box.position.set(
              Math.random() * 15 - 7.5,
              25,
              Math.random() * 15 - 7.5
            );

            box.rotation.set(
              Math.random() * Math.PI,
              Math.random() * Math.PI,
              Math.random() * Math.PI
            );

            box.castShadow = true;
            box.addEventListener("ready", spawnBox);
            scene.add(box);
          };

        let createSphere = function () {
          var sphere, material;

          material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
              color: getRandomColor(),
              // envMap: scene.background,
              // combine: THREE.MixOperation,
              // reflectivity: 0.1,
              // transparent: true,
              // opacity: 0.98
            }),
            0.5, // medium friction
            3 // low restitution
          );
          sphere = new Physijs.SphereMesh(sphere_geometry, material);
          sphere.collisions = 0;

          sphere.position.set(0, 0, 0);

          sphere.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );

          sphere.castShadow = true;
          sphere.addEventListener("collision", handleCollision);
          sphere.gameName = "SPHERE0";
          scene.add(sphere);
        };
        return () => {
          createSphere();

          const sidesColor = getRandomColor();

          const glassMesh0 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(1000, 1000, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0,
              transparent: true,
              wifeframe: true,
            }),
            /*mass*/ 0
          );
          glassMesh0.gameName = "FRONTGLASS";
          glassMesh0.name = "glassMesh0";

          const glassMesh1 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(1000, 1000, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0.0,
              transparent: true,
              wifeframe: true,
            }),
            /*mass*/ 0
          );
          glassMesh1.gameName = "BACKGLASS";
          glassMesh1.name = "glassMesh1";

          const stageFloor = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(25, 1, 10),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0,
              transparent: true,
            }),
            /*mass*/ 0
          );

          stageFloor.name = "stageFloor";
          stageFloor.featureType = "STAGEFLOOR";
          const catchWall = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(25, 10, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0,
              transparent: true,
            }),
            /*mass*/ 0
          );

          catchWall.name = "catchWall";
          catchWall.featureType = "CATCHWALL";

          catchWall.position.y = -327;
          catchWall.position.z = 5;
          glassMesh0.position.z = 1.5;
          glassMesh1.position.z = -1.5;
          glassMesh0.position.y = -137.5;
          glassMesh1.position.y = -140;
          stageFloor.position.y = -327;
          stageFloor.rotation.x = Math.PI * 0.125;
          glassMesh0.__dirtyPosition = true;
          glassMesh0.__dirtyRotation = true;
          glassMesh1.__dirtyPosition = true;
          glassMesh1.__dirtyRotation = true;

          scene.add(glassMesh0);
          scene.add(glassMesh1);
          scene.add(stageFloor);
          scene.add(catchWall);

          window.appConfig.initialBallZoomReset = () => {
            window.appConfig.initialBallZoom = {
              userHasClickedStart: false,
              started: 0,
              ended: 0,
              z: scene.children.find((obj) => obj.gameName === "SPHERE0")
                .position.z,
              percentComplete: 0,
              time: 2000,
              timeLeft: 1000,
              currentTime: 0,
            };
          };

          window.appConfig.stageResultsBallZoomReset = () => {
            window.appConfig.stageResultsBallZoom = {
              userHasEnded: false,
              started: 0,
              ended: 0,
              z: scene.children.find((obj) => obj.gameName === "SPHERE0")
                .position.z,
              percentComplete: 0,
              time: 2000,
              timeLeft: 1000,
              currentTime: 0,
            };
          };

          window.appConfig.stageResetReset = () => {
            window.appConfig.stageReset = {
              userHasEndedReport: false,
              started: 0,
              ended: 0,
              z: scene.children.find((obj) => obj.gameName === "SPHERE0")
                .position.z,
              percentComplete: 0,
              time: 2000,
              timeLeft: 1000,
              currentTime: 0,
            };
          };

          window.appConfig.initialBallZoomReset();
          window.appConfig.stageResultsBallZoomReset();
          window.appConfig.stageResetReset();
        };
      })();

      let appStartTime = new Date().getTime();
      let initialBallZoomTime = 0;

      render = function () {

        const stage0 = scene.children.find((obj) => obj.name === "STAGE0MAINSTRUCTURE")
        stage0.rotation.z += .001
        stage0.__dirtyRotation = true

        if (
          window.appConfig.stageReset.userHasEndedReport &&
          window.appConfig.stageReset.started === 0 &&
          window.appConfig.stageReset.ended === 0
        ) {
          window.appConfig.stageReset.started = new Date().getTime();
          window.appConfig.stageReset.currentTime = new Date().getTime();
        }

        if (
          window.appConfig.stageReset.started !== 0 &&
          window.appConfig.stageReset.ended === 0
        ) {
          let currentTime = new Date().getTime();
          window.appConfig.stageReset.currentTime = currentTime;
          let percentComplete =
            (currentTime - window.appConfig.stageReset.started) /
            window.appConfig.stageReset.time;
          window.appConfig.stageReset.percentComplete = percentComplete;
          console.log(
            "time left: " + (currentTime - window.appConfig.stageReset.started)
          );
          console.log("time left %: " + percentComplete);
          let mesh = scene.children.find((obj) => obj.gameName === "SPHERE0");
          if (
            currentTime - window.appConfig.stageReset.started >
            window.appConfig.stageReset.time
          ) {
            window.appConfig.stageReset.ended = new Date().getTime();
            mesh.position.set(0, 0, 0);
            mesh.__dirtyPosition = true;
            camera.position.set(0, 10, 10);
            camera.lookAt(new THREE.Vector3(0, 10, 0));
            document.querySelector("#start-button").classList.remove("hide");
            document.querySelector("#report").classList.add("hide");
            window.appConfig.start = false;
            window.appConfig.stageResultsBallZoomReset();
            window.appConfig.initialBallZoomReset();
            window.appConfig.stageResetReset();
          }
        }

        if (
          window.appConfig.stageResultsBallZoom.userHasEnded &&
          window.appConfig.stageResultsBallZoom.started === 0 &&
          window.appConfig.stageResultsBallZoom.ended === 0
        ) {
          window.appConfig.stageResultsBallZoom.started = new Date().getTime();
          window.appConfig.stageResultsBallZoom.currentTime = new Date().getTime();
        }

        if (
          window.appConfig.stageResultsBallZoom.started !== 0 &&
          window.appConfig.stageResultsBallZoom.ended === 0
        ) {
          let currentTime = new Date().getTime();
          window.appConfig.stageResultsBallZoom.currentTime = currentTime;
          let percentComplete =
            (currentTime - window.appConfig.stageResultsBallZoom.started) /
            window.appConfig.stageResultsBallZoom.time;
          window.appConfig.stageResultsBallZoom.percentComplete = percentComplete;
          console.log(
            "time left: " +
              (currentTime - window.appConfig.stageResultsBallZoom.started)
          );
          console.log("time left %: " + percentComplete);
          if (
            currentTime - window.appConfig.stageResultsBallZoom.started >
            window.appConfig.stageResultsBallZoom.time
          ) {
            window.appConfig.stageResultsBallZoom.ended = new Date().getTime();
            console.log(appConfig.stageResultsBallZoom);
          }
        }

        if (
          window.appConfig.initialBallZoom.userHasClickedStart &&
          window.appConfig.initialBallZoom.started === 0 &&
          window.appConfig.initialBallZoom.ended === 0
        ) {
          window.appConfig.initialBallZoom.started = new Date().getTime();
          window.appConfig.initialBallZoom.currentTime = new Date().getTime();
        }

        if (
          window.appConfig.initialBallZoom.started !== 0 &&
          window.appConfig.initialBallZoom.ended === 0
        ) {
          let currentTime = new Date().getTime();
          window.appConfig.initialBallZoom.currentTime = currentTime;
          let percentComplete =
            (currentTime - window.appConfig.initialBallZoom.started) /
            window.appConfig.initialBallZoom.time;
          window.appConfig.initialBallZoom.percentComplete = percentComplete;
          console.log(
            "time left: " +
              (currentTime - window.appConfig.initialBallZoom.started)
          );
          console.log("time left %: " + percentComplete);
          if (
            currentTime - window.appConfig.initialBallZoom.started >
            window.appConfig.initialBallZoom.time
          ) {
            window.appConfig.initialBallZoom.ended = new Date().getTime();
            console.log(appConfig.initialBallZoom);
          }
        }

        const sphere = scene.children.find((obj) => obj.gameName === "SPHERE0");

        if (
          window.appConfig.start === false ||
          window.appConfig.pause === true
        ) {
          if (window.appConfig.start === false) {
            sphere.position.set(0, 10, 0);
          }
          scene.children
            .find((obj) => obj.gameName === "SPHERE0")
            .setLinearVelocity(new THREE.Vector3(0, 0, 0));
        } else {
          if (
            window.appConfig.touchStart === true &&
            window.appConfig.touchEnd === false
          ) {
            console.log("ACTIVE!!!");
            const scaleV = 0.5;
            scene.children
              .find((obj) => obj.gameName === "SPHERE0")
              .setLinearVelocity(
                new THREE.Vector3(
                  window.appConfig.diffX * scaleV,
                  window.appConfig.diffY * -scaleV,
                  0
                )
              );
          }
        }

        const spherePosition = scene.children.find(
          (obj) => obj.gameName === "SPHERE0"
        ).position;
        scene.children
          .find((obj) => obj.gameName === "POINTLIGHT0")
          .position.set(
            spherePosition.x,
            spherePosition.y + 1,
            spherePosition.z
          );

        const stageFloor = scene.children.find(
          (obj) => obj.name === "stageFloor"
        );
        const compareVector = new THREE.Vector3();
        const distanceSphereToStageFloor = compareVector
          .subVectors(
            new THREE.Vector3().setFromMatrixPosition(sphere.matrixWorld),
            new THREE.Vector3().setFromMatrixPosition(stageFloor.matrixWorld)
          )
          .length();
        const percentFinished = distanceSphereToStageFloor / 375;
        window.appConfig.percentFinished = percentFinished;
        if (new Date().getTime() % 10 < 3) {
          document.body.style.background =
            "linear-gradient(180deg, rgba(2,0,36,0) 0%, rgba(121,9,117,1) 0%, rgba(252,231,183,1) " +
            Math.round((1 - percentFinished) * 100) / 3 +
            "%, rgba(0,212,255,1)" +
            Math.round((1 - percentFinished) * 100) +
            "%)";
        }
        camera.position.x = sphere.position.x;
        camera.position.y = sphere.position.y;
        camera.position.z =
          10 +
          90 * window.appConfig.initialBallZoom.percentComplete -
          window.appConfig.stageResultsBallZoom.percentComplete * 90 -
          window.appConfig.stageReset.percentComplete * 5;

        if (window.appConfig.stageResultsBallZoom.userHasEnded) {
          scene.children
            .find((obj) => obj.gameName === "SPHERE0")
            .setLinearVelocity(new THREE.Vector3(0, 0, 0));
          scene.children
            .find((obj) => obj.gameName === "SPHERE0")
            .setAngularVelocity(new THREE.Vector3(0, 0, 0));
        }
        // }

        Object.keys(window.appConfig.featureTypes).forEach((key) => {
          window.appConfig.featureTypes[key].forEach(
            (feature, featureIndex) => {
              const newXRotation = feature.rotation.x + 0.01;
              const newYRotation = feature.rotation.y + 0.01;
              const newZRotation = feature.rotation.z + 0.01;
              feature.rotation.x = newXRotation;
              feature.rotation.y = newYRotation;
              feature.rotation.z = newZRotation;
              feature.__dirtyRotation = true;
            }
          );
        });
        let coinIndexToRemove = undefined;
        const potentiallyGrabbedCoin = window.appConfig.coins.find(
          (coin, coinIndex) => {
            coinIndexToRemove = coinIndex;
            return (
              Math.abs(coin.position.x - sphere.position.x) <
                coin.scale.z * 1.3 &&
              Math.abs(coin.position.y - sphere.position.y) < coin.scale.z * 1.3
            );
          }
        );

        if (potentiallyGrabbedCoin) {
          window.appConfig.score.coins += potentiallyGrabbedCoin.coinValue;
          scene.remove(potentiallyGrabbedCoin);
          window.appConfig.coins.splice(coinIndexToRemove, 1);
          potentiallyGrabbedCoin.geometry.dispose();
          potentiallyGrabbedCoin.material.dispose();
          document.querySelector("#score").innerText =
            window.appConfig.score.coins;
        }
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        render_stats.update();
      };

      const start = () => {
        window.appConfig.start = true;
        document.querySelector("#start-button").classList.add("hide");
        document.querySelector("#title").classList.add("hide");
        document.querySelector("#start-menu").classList.add("hide");
        document.querySelector("#game-scoreboard").classList.remove("hide");
        document.querySelector("#pause-button").classList.remove("hide");
        window.appConfig.initialBallZoom.userHasClickedStart = true;
        window.appConfig.timer.start();
        document.querySelector("#pause-button").disabled = false;
      };

      const pause = () => {
        window.appConfig.pause
          ? backgroundMusic0.play()
          : backgroundMusic0.pause();
        window.appConfig.pause = !window.appConfig.pause;
        if (window.appConfig.pause) {
          window.appConfig.timer.pause();
        } else {
          window.appConfig.timer.start();
        }
      };

      const reset = () => {
        window.appConfig.stageReset.userHasEndedReport = true;
        document.querySelector("#level-select").classList.add("hide");
        document.querySelector("#curtain").classList.remove("opacity-0");
        document.querySelector("#report").classList.add("hide");
        document.querySelector("#game-scoreboard").classList.add("hide");

        setTimeout(() => {
          console.log("fired");
          document.querySelector("#curtain").classList.add("opacity-0");
        }, 2000);
        window.appConfig.timer.reset();
        window.appConfig.timer.pause();
      };
      const showLevelSelect = () => {
        document.querySelector("#level-select").classList.remove("hide");
        centerElement({ id: "level-select", offsetTop: 0, offsetLeft: 0 });
        document.querySelector("#start-menu").classList.add("hide");
        document.querySelector("#pause-menu").classList.add("hide");
        document.querySelector("#start-button").classList.add("hide");
        document.querySelector("#report").classList.add("hide");
        document.querySelector("#title").classList.add("hide");
      };
      const showSettings = () => {
        console.log("clicked settings");
      };
      const showCredits = () => {
        console.log("clicked credits");
      };
      const centerElement = (options) => {
        const { id, offsetLeft, offsetTop } = options;
        const element = document.getElementById(id);
        const buttonHeight = element.offsetHeight;
        const buttonWidth = element.offsetWidth;
        const offsetHeight =
          window.innerHeight / 2 - buttonHeight / 2 + offsetTop;
        const offsetWidth =
          window.innerWidth / 2 - buttonWidth / 2 + offsetLeft;
        const root = document.documentElement;
        root.style.setProperty(`--${id}-offset-top`, offsetHeight + "px");
        root.style.setProperty(`--${id}-offset-left`, offsetWidth + "px");
      };
      window.onload = initScene;
    </script>
    <style>
      :root {
      }
      @font-face {
        font-family: "Aadhunik";
        src: url("./fonts/Aadhunik.ttf") format("truetype");
      }
      @font-face {
        font-family: "Coves Light";
        src: url("./fonts/Coves Light.otf") format("opentype");
      }
      @font-face {
        font-family: "Luz Sans Book";
        src: url("./fonts/LUZRO.ttf") format("truetype");
      }
      button:focus {
        outline: none;
        box-shadow: none;
      }
      #start-button {
        font-family: "Luz Sans Book";
        font-size: 2.5em;
        position: fixed;
        left: var(--start-button-offset-left);
        top: var(--start-button-offset-top);
        padding: 10px 30px;
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
        background-color: rgba(0, 0, 0, 0);
        color: #ffffff;
      }
      #level-select-title {
        font-family: "Luz Sans Book";
        font-size: 2em;
        color: #ffffff;
        margin: 0 auto;
        text-align: center;
      }
      #title {
        font-family: "Aadhunik";
        position: fixed;
        top: var(--title-offset-top);
        left: var(--title-offset-left);
        font-size: 4em;
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
        background-color: rgba(0, 0, 0, 0);
        color: #ffffff;
      }
      #report {
        position: fixed;
        left: var(--report-offset-left);
        top: var(--report-offset-top);
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
        background-color: rgba(0, 0, 0, 0);
      }
      #pause-menu {
        position: fixed;
        left: var(--pause-menu-offset-left);
        top: var(--pause-menu-offset-top);
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
        background-color: rgba(0, 0, 0, 0);
      }
      #level-select {
        position: fixed;
        left: var(--level-select-offset-left);
        top: var(--level-select-offset-top);
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
        background-color: rgba(0, 0, 0, 0);
      }
      #level-select table,
      #level-select table td {
        padding: 5px;
        margin: 0 auto;
        text-align: center;
      }
      #start-menu {
        font-family: "Coves Light";
        position: fixed;
        left: var(--start-menu-offset-left);
        top: var(--start-menu-offset-top);
        border: 0;
        border-radius: 5px;
        background-color: rgba(0, 0, 0, 0);
        opacity: 0.75;
      }
      .start-menu-button {
        display: block;
        font-family: "Coves Light";
        font-size: 1.75em;
        font-weight: 500;
        border: 0;
        border-radius: 5px;
        opacity: 1;
        background-color: rgba(0, 0, 0, 0);
        color: #ffffff;
      }

      #pause-button {
        position: fixed;
        font-family: "Luz Sans Book";
        font-size: 2em;
        left: 3%;
        bottom: 3%;
        padding: 10px 30px;
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
      }
      .hide {
        display: none;
        visibility: hidden;
      }
      #game-scoreboard {
        position: fixed;
        top: 3%;
        right: 3%;
      }
      #timer,
      #score,
      #report-time,
      #report-coins,
      #report td {
        font-family: "Coves Light";
        font-size: 2em;
        color: #ffffff;
      }
      .level-select-button {
        font-family: "Coves Light";
        font-size: 1.75em;
        font-weight: 500;
        border: 0;
        border-radius: 5px;
        opacity: 1;
        background-color: rgba(0, 0, 0, 0);
        color: #ffffff;
      }

      #curtain {
        transition: all 2000ms;
        pointer-events: none;
        background-color: white;
        z-index: 1;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 1;
      }

      .opacity-0 {
        opacity: 0 !important;
      }

      .opacity-1 {
        opacity: 1 !important;
      }
    </style>
  </head>

  <body>
    <div id="viewport"></div>
    <div id="game-scoreboard">
      <div id="timer"></div>
      <div id="score"></div>
    </div>
    <div id="report" class="hide">
      <table>
        <tr>
          <td>Time:</td>
          <td id="report-time"></td>
        </tr>
        <tr>
          <td>Crystals:</td>
          <td id="report-coins"></td>
        </tr>
        <tr>
          <td>Score:</td>
          <td id="report-score"></td>
        </tr>
      </table>
      <button
        id="report-level-select-button"
        class="start-menu-button"
        onClick="showLevelSelect()"
      >
        Level Select
      </button>
      <button
        id="report-reset-button"
        class="start-menu-button"
        onClick="reset({action:'reset'})"
      >
        Try Again
      </button>
      <button
        id="report-reset-button"
        class="start-menu-button"
        onClick="reset({action:'next'})"
      >
        Next Level
      </button>
    </div>
    <div id="level-select" class="hide">
      <div id="level-select-title">Level Select</div>
      <table>
        <tr>
          <td class="level-select-button" onClick="reset({action:1})">1</td>
          <td class="level-select-button" onClick="reset({action:2})">2</td>
          <td class="level-select-button" onClick="reset({action:3})">3</td>
          <td class="level-select-button" onClick="reset({action:4})">4</td>
          <td class="level-select-button" onClick="reset({action:5})">5</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="reset({action:6})">6</td>
          <td class="level-select-button" onClick="reset({action:7})">7</td>
          <td class="level-select-button" onClick="reset({action:8})">8</td>
          <td class="level-select-button" onClick="reset({action:9})">9</td>
          <td class="level-select-button" onClick="reset({action:10})">10</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="reset({action:11})">11</td>
          <td class="level-select-button" onClick="reset({action:12})">12</td>
          <td class="level-select-button" onClick="reset({action:13})">13</td>
          <td class="level-select-button" onClick="reset({action:14})">14</td>
          <td class="level-select-button" onClick="reset({action:15})">15</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="reset({action:16})">16</td>
          <td class="level-select-button" onClick="reset({action:17})">17</td>
          <td class="level-select-button" onClick="reset({action:18})">18</td>
          <td class="level-select-button" onClick="reset({action:19})">19</td>
          <td class="level-select-button" onClick="reset({action:20})">20</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="reset({action:21})">21</td>
          <td class="level-select-button" onClick="reset({action:22})">22</td>
          <td class="level-select-button" onClick="reset({action:23})">23</td>
          <td class="level-select-button" onClick="reset({action:24})">24</td>
          <td class="level-select-button" onClick="reset({action:25})">25</td>
        </tr>
      </table>
    </div>

    <div id="pause-menu" class="hide"></div>
    <div id="title">BALLSINKI</div>
    <button id="start-button" onClick="start()">Start</button>
    <div id="start-menu">
      <button
        id="start-level-select-button"
        class="start-menu-button"
        onClick="showLevelSelect()"
      >
        Level Select
      </button>
      <button
        id="start-settings-button"
        class="start-menu-button"
        onClick="showSettings()"
      >
        Settings
      </button>
      <button
        id="start-credits-button"
        class="start-menu-button"
        onClick="showCredits()"
      >
        Credits
      </button>
    </div>
    <button id="pause-button" disabled class="hide" onClick="pause()">
      II
    </button>
    <div id="curtain"></div>
  </body>
</html>
