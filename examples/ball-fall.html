<!DOCTYPE html>

<html>
  <head>
    <title>Ball Fall</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
      }
      html {
        touch-action: none;
      }
    </style>
    <link rel="stylesheet" href="./ballsinki.css">
    <script type="text/javascript" src="js/ammo.js"></script>
    <script type="text/javascript" src="js/three-121.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="js/physi.js"></script>
    <script type="text/javascript" src="js/physijs_worker.js"></script>
    <!-- <script type="text/javascript" src="js/THREEOrbitControls.js"></script> -->
    <script type="text/javascript" src="js/easytimer.js"></script>
    <script type="text/javascript" src="js/howler.min.js"></script>
    <!-- <script src="https://unpkg.com/three@0.112.0/examples/js/loaders/GLTFLoader.js"></script> -->
    <script type="text/javascript" src="./features.js"></script>
    <script type="text/javascript">
      "use strict";

      window.appConfig = {
        touchStart: false,
        touchEnd: false,
        currentX: 0,
        currentY: 0,
        prevX: 0,
        prevY: 0,
        diffX: 0,
        diffY: 0,
        start: false,
        pause: false,
        results: {},
        pause: false,
        itemAmounts: {
          crystalCross: 0,
          crystalLine: 0,
          bumperGroup: 0,
          prize: 0
        },
        currentStage: 'STAGE0'
      };

      const backgroundMusics = [];
      const howlSounds = [];
      window.appConfig.howlSounds = howlSounds;
      window.appConfig.backgroundMusics = backgroundMusics;
      const loadSound = (options) => {
        const { src, type } = options;
        const sound = new Howl({
          src: [src],
          autoPlay: type === "backgroundMusic" ? true : false,
          loop: type === "backgroundMusic" ? true : false,
          volume: type === "backgroundMusic" ? 0.1 : 1,
        }).once("load", () => {
          if (type === "backgroundMusic") {
            backgroundMusics.push(sound);
            sound.play();
          } else {
            howlSounds.push(sound);
          }
        });
        return sound;
      };
      const backgroundMusic0 = loadSound({
        src: "sounds/BALL FALL jingle flat 1.mp3",
        type: "backgroundMusic",
      })
        .on("playerror", (id, e) => {
          console.log("playerror callback");
          console.dir(id);
          console.dir(e);
        })
        .on("fade", (e) => {
          console.log("fade callback");
          console.dir(e);
          console.dir(this);
        });
      const howlSound0 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a1.mp3",
        type: "howlSound",
      });
      const howlSound1 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a2.mp3",
        type: "howlSound",
      });
      const howlSound2 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a3.mp3",
        type: "howlSound",
      });
      const howlSound3 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a4.mp3",
        type: "howlSound",
      });
      const howlSound4 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a5.mp3",
        type: "howlSound",
      });
      const howlSound5 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a6.mp3",
        type: "howlSound",
      });
      const howlSound6 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a7.mp3",
        type: "howlSound",
      });
      const howlSound7 = loadSound({
        src: "sounds/Sound FX/BALL FALL fx a8.mp3",
        type: "howlSound",
      });

      Physijs.scripts.worker = "js/physijs_worker.js";
      Physijs.scripts.ammo = "ammo.js";

      const basicColors = [
        new THREE.Color(0xfff1e3),
        new THREE.Color(0xffd5c9),
        new THREE.Color(0xffa6bb),
        new THREE.Color(0xff757f),
        new THREE.Color(0x159294),
      ];

      let adjustCamera = 20;

      const getRandomColor = () => {
        return basicColors[Math.floor(Math.random() * basicColors.length)];
      };

      // LFO
      const lfoPositive = (t = 1000) => {
        let lfoValue = (0.5 + 0.5 * Math.cos(Date.now() / t)) * 1;
        return lfoValue;
      };

      const lfo = (t = 1000) => {
        return (0.5 - lfoPositive(t)) * 2;
      };

      var initScene,
        render,
        _boxes = [],
        spawnBox,
        loader,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground_material,
        ground,
        light,
        camera,
        orbitControls;

        // const raycaster = new THREE.Raycaster();
        //   const mouse = new THREE.Vector2();

        //   function onMouseMove( event ) {

        //     // calculate mouse position in normalized device coordinates
        //     // (-1 to +1) for both components

        //     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        //     mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        //   }

      initScene = function () {
        window.appConfig.soundsBackDestination = "";
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById("viewport").appendChild(renderer.domElement);

        render_stats = new Stats();
        render_stats.domElement.style.position = "absolute";
        render_stats.domElement.style.top = "0px";
        render_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(render_stats.domElement);

        physics_stats = new Stats();
        physics_stats.domElement.style.position = "absolute";
        physics_stats.domElement.style.top = "50px";
        physics_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(physics_stats.domElement);

        scene = new Physijs.Scene();

        scene.setGravity(new THREE.Vector3(0, -10, 0));

        scene.addEventListener("update", function () {
          scene.simulate(undefined, 1);
          physics_stats.update();
        });

        const skyColor = getRandomColor();
        const groundColor = getRandomColor();
        const hemisphereLight = new THREE.HemisphereLight(
          skyColor,
          groundColor,
          0.75
        );
        scene.add(hemisphereLight);

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );

        adjustCamera = 20;
        camera.position.set(0, 10, 10);
        camera.lookAt(new THREE.Vector3(0, 10, 0));
        scene.add(camera);

        // Light
        light = new THREE.SpotLight(0xffffff);
        light.position.set(20, 80, 15);
        light.target.position.copy(scene.position);
        light.castShadow = true;
        light.shadowCameraLeft = -60;
        light.shadowCameraTop = -60;
        light.shadowCameraRight = 60;
        light.shadowCameraBottom = 60;
        light.shadowCameraNear = 20;
        light.shadowCameraFar = 200;
        light.shadowBias = -0.0001;
        light.shadowMapWidth = light.shadowMapHeight = 2048;
        light.shadowDarkness = 0.7;
        scene.add(light);

        const pointLight0 = new THREE.PointLight(getRandomColor(), 1);
        pointLight0.gameName = "POINTLIGHT0";
        pointLight0.power = 25;
        pointLight0.decay = 1;
        pointLight0.distance = 25;
        scene.add(pointLight0);

        // Orbit Controls
        // orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        // orbitControls.enabled = false;

        //resize event handler
        function onWindowResize(event) {
          //put the start button right in the middle!
          centerElement({ id: "start-button", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "level-select", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "report", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "pause-menu", offsetTop: 0, offsetLeft: 0 });
          centerElement({ id: "title", offsetTop: -200, offsetLeft: 0 });
          centerElement({ id: "start-menu", offsetTop: 200, offsetLeft: 0 });
          // remember these initial values
          var tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
          var windowHeight = window.innerHeight;
          camera.aspect = window.innerWidth / window.innerHeight;

          // adjust the FOV
          camera.fov =
            (360 / Math.PI) *
            Math.atan(tanFOV * (window.innerHeight / windowHeight));

          camera.updateProjectionMatrix();
          // camera.lookAt(scene.position);

          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.render(scene, camera);
        }
        onWindowResize();
        window.addEventListener("resize", onWindowResize, false);

        loader = new THREE.TextureLoader();

        let level = 25;
        window.appConfig.level = level;
        let score = {
          coins: 0,
        };
        window.appConfig.score = score;

        const featureTypes = {
          ramp: [],
          cone: [],
          icosahedron: [],
          tetrahedron: [],
          torus: [],
          disc: [],
        };

        window.appConfig.featureTypes = featureTypes;
        const defaultYLanes = [16, 8, 0, -8, -16]; // to copy, splice, and then populate openSpots
        const openSpots = [];
        window.appConfig.openSpots = openSpots;
        const coins = [];
        window.appConfig.coins = coins;

        const createBeam = (config) => {
          const beam0 = new Physijs.BoxMesh(
            new THREE.BoxGeometry(10 * config.s, 2, 2),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                color: config.color ? config.color : 0xffffff,
              }),
              0.6, // medium friction
              0.1 // low restitution
            ),
            0 // mass
          );
          const beam0cap0 = new Physijs.BoxMesh(
            new THREE.BoxGeometry(1.45, 2, 1.45),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                color: config.color ? config.color : 0xffffff,
              }),
              0.6, // medium friction
              0.1 // low restitution
            ),
            0 // mass
          );
          const beam0cap1 = new Physijs.BoxMesh(
            new THREE.BoxGeometry(1.45, 2, 1.45),
            Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                color: config.color ? config.color : 0xffffff,
              }),
              0.6, // medium friction
              0.1 // low restitution
            ),
            0 // mass
          );
          beam0cap0.rotation.y = 0.25 * Math.PI;
          beam0cap0.position.x = -5 * config.s;
          beam0.add(beam0cap0);
          beam0cap1.rotation.y = 0.25 * Math.PI;
          beam0cap1.position.x = 5 * config.s;
          beam0.add(beam0cap1);
          beam0.position.set(config.p[0], config.p[1], config.p[2]);
          beam0.rotation.set(config.r[0], config.r[1], config.r[2]);
          return beam0;
        };

        const crystal = (size = 0, p = { x: 0, y: 0, z: 0 }) => {
          const tripleHex = 0x159294;
          const doubleHex = 0xffa6bb;
          const singleHex = 0xffd5c9;
          const tripleScale = 2;
          const doubleScale = 1.5;
          const singleScale = 1;
          const xScaleMod = 0.5;
          const yScaleMod = 1;
          const zScaleMod = 0.5;

          const crystalMaterialOptions = {
            color: 0x000000,
            specular: 0x050505,
            shininess: 100
          };

          const coin = new THREE.Mesh();
          const crystalTop = new THREE.Mesh(
            new THREE.CylinderGeometry(0, 1, 0.5, 6),
            new THREE.MeshPhongMaterial(crystalMaterialOptions)
          );
          crystalTop.translateY(0.75);
          const crystalMiddle = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 1, 6),
            new THREE.MeshPhongMaterial(crystalMaterialOptions)
          );

          const crystalBottom = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 0, 0.5, 6),
            new THREE.MeshPhongMaterial(crystalMaterialOptions)
          );
          crystalBottom.translateY(-0.75);
          coin.add(crystalTop);
          coin.add(crystalMiddle);
          coin.add(crystalBottom);
          coin.position.set(p.x, p.y, 0);
          coin.featureType = "COIN";
          if (size === 0) {
            coin.scale.set(
              singleScale * xScaleMod,
              singleScale * yScaleMod,
              singleScale * zScaleMod
            );
            coin.coinType = "single";
            coin.coinValue = 1;
            coin.children.forEach((child) => {
              child.material.color.setHex(singleHex);
            });
          }
          if (size === 1) {
            coin.scale.set(
              doubleScale * xScaleMod,
              doubleScale * yScaleMod,
              doubleScale * zScaleMod
            );
            coin.coinType = "double";
            coin.coinValue = 2;
            coin.children.forEach((child) => {
              child.material.color.setHex(doubleHex);
            });
          }

          if (size === 2) {
            coin.scale.set(
              tripleScale * xScaleMod,
              tripleScale * yScaleMod,
              tripleScale * zScaleMod
            );
            coin.coinType = "triple";
            coin.coinValue = 3;
            coin.children.forEach((child) => {
              child.material.color.setHex(tripleHex);
            });
          }
          coins.push(coin);
          return coin;
        };

        const createCrystalCross = (s, t = { x: 0, y: 0 }, size = 0) => {
          const crystalCross = new THREE.Group()
          crystalCross.debugTypeIndex = window.appConfig.itemAmounts.crystalCross
          crystalCross.debugType = 'CRYSTALCROSS' 
          crystalCross.debugName = 'CRYSTALCROSS' + window.appConfig.itemAmounts.crystalCross
          
          crystalCross.add(crystal(size, { x: 0 * s + t.x, y: 1 * s + t.y, z: 0 }));
          crystalCross.add(crystal(size, { x: 0 * s + t.x, y: -1 * s + t.y, z: 0 }));
          crystalCross.add(crystal(size, { x: -1 * s + t.x, y: 0 * s + t.y, z: 0 }));
          crystalCross.add(crystal(size, { x: 1 * s + t.x, y: 0 * s + t.y, z: 0 }));
          scene.add(crystalCross)
          window.appConfig.itemAmounts.crystalCross++
        };

        const createCrystalLine = (
          s,
          t = { x: 0, y: 0 },
          size = 0,
          n,
          dir = "x"
        ) => {
          const crystalLine = new THREE.Group()
          crystalLine.debugTypeIndex = window.appConfig.itemAmounts.crystalLine
          crystalLine.debugType = 'CRYSTALLINE' 
          crystalLine.debugName = 'CRYSTALLINE' + window.appConfig.itemAmounts.crystalLine
          let i = 0;
          for (i; i < n; i++) {
            if (dir === "x") {
              scene.add(crystal(size, { x: i * s + t.x, y: t.y, z: 0 }));
            } else {
              scene.add(crystal(size, { x: t.x, y: i * s + t.y, z: 0 }));
            }
          }
          window.appConfig.itemAmounts.crystalLine++
        };

        // start stage 0
        window.appConfig.stages = {
          STAGE0: {
            data: {
              started: false,
              xAdj: -60,
              vAdj: -70,
              sAdj: 2,
              startingPosition: new THREE.Vector3(0, 0, 0)
            },
            init: () => {
              const createStage0MainBeamStructure = (
              scale,
              scaleAdj = 0,
              name,
              p = { x: 0, y: 0 }
            ) => {
              const mainStructure = new Physijs.BoxMesh(
                new THREE.BoxGeometry(0.01, 0.01, 0.01),
                new Physijs.createMaterial(
                  new THREE.MeshPhongMaterial({ transparent: true, opacity: 0 }),
                  0.6,
                  0.3
                ),
                0
              );
              mainStructure.position.set(0 + p.x, 0 + p.y, 1.5);
              mainStructure.add(
                createBeam({
                  p: [0 * scale, -8 * scale, -1],
                  r: [0, 0, 0],
                  s: (1 + scaleAdj) * scale,
                })
              );
              mainStructure.add(
                createBeam({
                  p: [-8 * scale, 0 * scale, -1],
                  r: [0, 0, 0.5 * Math.PI],
                  s: (1 + scaleAdj) * scale,
                })
              );
              mainStructure.add(
                createBeam({
                  p: [8 * scale, 0 * scale, -1],
                  r: [0, 0, 0.5 * Math.PI],
                  s: (1 + scaleAdj) * scale,
                })
              );
              mainStructure.add(
                createBeam({
                  p: [0 * scale, 8 * scale, -1],
                  r: [0, 0, 0],
                  s: (1 + scaleAdj) * scale,
                })
              );
              mainStructure.name = name;
              mainStructure.__dirtyPosition = true;
              return mainStructure;
            };

            const stage0MainBeamStructure = createStage0MainBeamStructure(
              2,
              0,
              "STAGE0MAINSTRUCTURE"
            );
            scene.add(stage0MainBeamStructure);
            const stage0MainBeamStructure1 = createStage0MainBeamStructure(
              4,
              0,
              "STAGE0MAINSTRUCTURE1"
            );
            scene.add(stage0MainBeamStructure1);
            const stage0MainBeamStructure2 = createStage0MainBeamStructure(
              8,
              0.525,
              "STAGE0MAINSTRUCTURE2"
            );
            scene.add(stage0MainBeamStructure2);
            const stage0MinorBeamStructure = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE",
              { x: 45, y: 45 }
            );
            scene.add(stage0MinorBeamStructure);
            const stage0MinorBeamStructure1 = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE1",
              { x: 45, y: -45 }
            );
            scene.add(stage0MinorBeamStructure1);
            const stage0MinorBeamStructure2 = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE2",
              { x: -45, y: -45 }
            );
            scene.add(stage0MinorBeamStructure2);
            const stage0MinorBeamStructure3 = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE3",
              { x: -45, y: 45 }
            );
            scene.add(stage0MinorBeamStructure3);

            const prize0Group = new THREE.Group();
            const prize0 = new THREE.Mesh(
              new THREE.BoxGeometry(0.75, 0.75, 0.75),
              new THREE.MeshPhongMaterial()
            );
            const prize0Top = new THREE.Mesh(
              new THREE.ConeGeometry(1, 1, 8),
              new THREE.MeshPhongMaterial()
            );
            const prize0Bottom = new THREE.Mesh(
              new THREE.ConeGeometry(1, -1, 8),
              new THREE.MeshPhongMaterial()
            )
            prize0Group.name = 'STAGE0PRIZE0'
            prize0Group.debugTypeIndex = window.appConfig.itemAmounts.prize
            prize0Group.debugType = 'PRIZE' 
            prize0Group.debugName = 'PRIZE' + window.appConfig.itemAmounts.prize
            window.appConfig.itemAmounts.prize++

            prize0.name = 'PRIZE0'
            prize0Top.name = 'PRIZE0TOP'
            prize0Bottom.name = 'PRIZE0BOTTOM'


            prize0.rotation.set(.25 * Math.PI, .25 * Math.PI, 0)
            prize0Group.add(prize0)
            prize0Group.add(prize0Top)
            prize0Group.add(prize0Bottom)

            prize0Top.position.y += 1.5
            prize0Bottom.position.y += -1.5
            prize0Group.position.set(45, 45, 0)

            scene.add(prize0Group)
            const prize1Group = prize0Group.clone()
            prize1Group.position.set(45,-45,0)
            const prize2Group = prize0Group.clone()
            prize2Group.position.set(-45,-45,0)
            const prize3Group = prize0Group.clone()
            prize3Group.position.set(-45,45,0)
            prize1Group.name = 'STAGE0PRIZE1'
            prize2Group.name = 'STAGE0PRIZE2'
            prize3Group.name = 'STAGE0PRIZE3'
            scene.add(prize1Group)
            scene.add(prize2Group)
            scene.add(prize3Group)
            prize0Group.prizeValue = 10
            prize1Group.prizeValue = 10
            prize2Group.prizeValue = 20
            prize3Group.prizeValue = 10

            //add prizes to the coins array so that they can be collected in the same manner
            coins.push(prize0Group);
            coins.push(prize1Group);
            coins.push(prize2Group);
            coins.push(prize3Group);

            createCrystalCross(5);
            createCrystalCross(10);
            createCrystalCross(5, { x: 20, y: 20 }, 1);
            createCrystalCross(5, { x: -20, y: 20 }, 1);
            createCrystalCross(5, { x: -20, y: -20 }, 1);
            createCrystalCross(5, { x: 20, y: -20 }, 1);
            createCrystalCross(3, { x: 55, y: 55 }, 0);
            createCrystalCross(3, { x: 35, y: 55 }, 0);
            createCrystalCross(3, { x: 35, y: 35 }, 0);
            createCrystalCross(3, { x: 55, y: 35 }, 0);
            createCrystalCross(3, { x: 55, y: -55 }, 0);
            createCrystalCross(3, { x: 35, y: -55 }, 0);
            createCrystalCross(3, { x: 35, y: -35 }, 0);
            createCrystalCross(3, { x: 55, y: -35 }, 0);
            createCrystalCross(3, { x: -55, y: -55 }, 0);
            createCrystalCross(3, { x: -35, y: -55 }, 0);
            createCrystalCross(3, { x: -35, y: -35 }, 0);
            createCrystalCross(3, { x: -55, y: -35 }, 0);
            createCrystalCross(3, { x: -55, y: 55 }, 0);
            createCrystalCross(3, { x: -35, y: 55 }, 0);
            createCrystalCross(3, { x: -35, y: 35 }, 0);
            createCrystalCross(3, { x: -55, y: 35 }, 0);
            createCrystalLine(10, { x: -47.5, y: -20 }, 2, 5, "y");
            createCrystalLine(5, { x: 54.5, y: -22 }, 0, 10, "y");
            createCrystalLine(5, { x: 40.5, y: -22.5 }, 0, 10, "y");
            createCrystalLine(10, { x: 47.5, y: -20 }, 2, 5, "y");
            createCrystalLine(5, { x: -54.5, y: -22 }, 0, 10, "y");
            createCrystalLine(5, { x: -40.5, y: -22.5 }, 0, 10, "y");
            createCrystalLine(10, { x: -20, y: -47.5 }, 2, 5, "x");
            createCrystalLine(5, { x: -22.5, y: -40 }, 0, 10, "x");
            createCrystalLine(5, { x: -22.5, y: -54.5 }, 0, 10, "x");
            createCrystalLine(10, { x: -20, y: 47.5 }, 2, 5, "x");
            createCrystalLine(5, { x: -22.5, y: 40 }, 0, 10, "x");
            createCrystalLine(5, { x: -22.5, y: 54.5 }, 0, 10, "x");
            // end stage 0
            }       
          }
        }

        window.appConfig.stages.STAGE0.init()

        spawnBox();

        requestAnimationFrame(render);
        scene.simulate();
        const clickRay = new THREE.Raycaster();

        const timer = new easytimer.Timer({ precision: "secondTenths" });
        window.appConfig.timer = timer
        timer.addEventListener("secondTenthsUpdated", function (e) {
          document.querySelector(
            "#timer"
          ).innerText = `${timer
            .getTimeValues()
            .toString(["minutes", "seconds", "secondTenths"])}`;
        });
        const results = {};

        document.addEventListener("touchstart", (e) => {
          if (!window.appConfig.userHasEnded) {
            window.appConfig.touchEnd = false;
            window.appConfig.touchStart = true;
            window.appConfig.currentX = e.touches[0].clientX;
            window.appConfig.currentY = e.touches[0].clientY;

            window.appConfig.prevX = e.touches[0].clientX;
            window.appConfig.prevY = e.touches[0].clientY;
            window.appConfig.diffX =
              window.appConfig.currentX - window.appConfig.prevX;
            window.appConfig.diffY =
              window.appConfig.currentY - window.appConfig.prevY;
            console.log("TOUCHSTART", e);
            console.log("APPCONFIG", window.appConfig);
          }
        });

        window.appConfig.events = {touchmove: {throttle: 50, active: false}}

        document.body.addEventListener(
          "touchmove",
          (e) => {
            if (!window.appConfig.userHasEnded && window.appConfig.events.touchmove.active === false) {
              window.appConfig.events.touchmove.active = true
              window.appConfig.prevX = window.appConfig.currentX;
              window.appConfig.prevY = window.appConfig.currentY;
              window.appConfig.currentX = e.touches[0].clientX;
              window.appConfig.currentY = e.touches[0].clientY;
              window.appConfig.diffX =
                e.touches[0].clientX - window.appConfig.prevX;
              window.appConfig.diffY =
                e.touches[0].clientY - window.appConfig.prevY;
              console.log(
                "TOUCHMOVE",
                e.touches[0].clientX,
                e.touches[0].clientY
              );
              console.log("APPCONFIG", window.appConfig);
              console.log(window.appConfig.diffX, window.appConfig.diffY);
              e.preventDefault();
              setTimeout(() => {
                window.appConfig.events.touchmove.active = false
              }, window.appConfig.events.touchmove.throttle)
            }
          },
          true
        );

        document.addEventListener("touchend", (e) => {
          if (!window.appConfig.userHasEnded) {
            window.appConfig.touchEnd = true;
            window.appConfig.touchStart = false;
            window.appConfig.currentX = 0;
            window.appConfig.currentY = 0;
            window.appConfig.diffX = 0;
            window.appConfig.diffY = 0;
            console.log("TOUCHEND", e);
            console.log("APPCONFIG", window.appConfig);
          }
        });

        document.addEventListener("click", (e) => {
          e.preventDefault();
          console.log("CLICK", e);
          const normalized = new THREE.Vector2(e.clientX, e.clientY);
          clickRay.setFromCamera(normalized.normalize(), camera);

          console.log(
            clickRay.intersectObject(
              scene.children.find((obj) => obj.gameName === "FRONTGLASS")
            )
          );
          console.log("APPCONFIG", window.appConfig);
        });

        document.querySelector("#curtain").classList.add("opacity-0");
      };

      // app debug menu for items

      window.appConfig.debug = {
        stage: 0,
        debugKeyCodes: {
          left: 37,
          right: 39,
          up: 38,
          down: 40,
          leftBracket: 188,
          rightBracket: 190
        },
        currentDebugMeshIndex: 4
      }

      const incrementDebugObject = () => {
        window.appConfig.debug.currentDebugMeshIndex++
        if(window.appConfig.debug.currentDebugMeshIndex >= scene.children.length) {
          currentDebugMeshIndex = 4
        }
        console.log(window.appConfig.debug)
      }

      const decrementDebugObject = () => {
        window.appConfig.debug.currentDebugMeshIndex--
        if(window.appConfig.debug.currentDebugMeshIndex <= 4) {
          currentDebugMeshIndex = scene.children.length
        }
        console.log(window.appConfig.debug)
      }

      const translateObject = (e) => {
        const s = 5
        const objectToTranslate = scene.children[window.appConfig.debug.currentDebugMeshIndex]
        const dirs = {
          37: {x: -5, y: 0, z: 0},
          39: {x: 5, y: 0, z: 0},
          38: {x: 0, y: 5, z: 0},
          40: {x: 0, y: -5, z: 0}
        }
        objectToTranslate.position.x += dirs[e.keyCode].x
        objectToTranslate.position.y += dirs[e.keyCode].y
        console.log(window.appConfig.debug)
      }

      const keydownFunctions = {
        37:(e) => translateObject(e),
        39:(e) => translateObject(e),
        38:(e) => translateObject(e),
        40:(e) => translateObject(e),
        188:decrementDebugObject,
        190:incrementDebugObject
      }

      const keycodesArray = Object.values(window.appConfig.debug.debugKeyCodes)
      document.addEventListener('keydown', function(e) {
        if(keycodesArray.indexOf(e.keyCode) > -1) {
          console.log('Keydown event fired')
          console.log(e)
          console.log(e.keyCode)
          keydownFunctions[e.keyCode](e)
        }
      }); 

      spawnBox = (function () {
        var sphere_geometry = new THREE.SphereGeometry(1, 32, 32),
          collisionInc = 0,
          lastCollisions = ["","",""],
          handleCollision = function (
            collided_with,
            linearVelocity,
            angularVelocity
          ) {
            console.log("collision");
            console.log("collided_with", collided_with);

            const suonousFeatureTypes = [
              "BEAM",
              "BOX",
              "ICOSAHEDRON",
              "TETRAHEDRON",
              "CONE",
              "DISC",
              "TORUS",
              "PLINKO",
              "COIN",
            ];
            
            const playHowlOnCollision = [
              function () {
                  howlSound0.play();
              },
              function () {
                  howlSound1.play();
              },
              function () {
                  howlSound2.play();
              },
              function () {
                  howlSound3.play();
              },
              function () {
                  howlSound4.play();
              },
              function () {
                  howlSound5.play();
              },
              function () {
                  howlSound6.play();
              },
              function () {
                  howlSound7.play();
              }
              ]
            if (suonousFeatureTypes.indexOf(collided_with.featureType) > -1) {
              
              const sphere = scene.children.find(obj => {
                if(obj.gameName==="SPHERE0" && obj.type==="Mesh") {
                  return obj
                }
              })
              const i = Math.floor(collisionInc % playHowlOnCollision.length)
              if (!(lastCollisions[0]===collided_with.uuid && lastCollisions[1]===collided_with.uuid && lastCollisions[2]===collided_with.uuid) ){
              playHowlOnCollision[i]()
              collisionInc++
              lastCollisions.push(collided_with.uuid)}
              if (lastCollisions.length >3) {
              lastCollisions.shift()
              }
              console.log("AFTERPLAY");
            }
          }

        let createSphere = function () {
          var sphere, material;

          material = Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0xffffff,
              // envMap: scene.background,
              // combine: THREE.MixOperation,
              reflectivity: 100,
              transparent: true,
              opacity: 0.95,
              specular: 0x050505,
              shininess: 200
            }),
            0.5, // medium friction
            1 // low restitution
          );
          sphere = new Physijs.SphereMesh(sphere_geometry, material);
          sphere.collisions = 0;
          // sphere.position.set(window.appConfig.stages[window.appConfig.currentStage].data.startingPosition);
          sphere.position.set(0,0,0);

          sphere.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );

          sphere.castShadow = true;
          sphere.addEventListener("collision", handleCollision);
          sphere.gameName = "SPHERE0";
          scene.add(sphere);
        };
        return () => {
          createSphere();

          const sidesColor = getRandomColor();

          const glassMesh0 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(1000, 1000, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0,
              transparent: true,
              wifeframe: true,
            }),
            /*mass*/ 0
          );
          glassMesh0.gameName = "FRONTGLASS";
          glassMesh0.name = "glassMesh0";

          const glassMesh1 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(1000, 1000, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0.0,
              transparent: true,
              wifeframe: true,
            }),
            /*mass*/ 0
          );
          glassMesh1.gameName = "BACKGLASS";
          glassMesh1.name = "glassMesh1";

          glassMesh0.position.z = 1.5;
          glassMesh1.position.z = -1.5;
          glassMesh0.position.y = -137.5;
          glassMesh1.position.y = -140;
          glassMesh0.__dirtyPosition = true;
          glassMesh0.__dirtyRotation = true;
          glassMesh1.__dirtyPosition = true;
          glassMesh1.__dirtyRotation = true;

          scene.add(glassMesh0);
          scene.add(glassMesh1);

        };
      })();

      let appStartTime = new Date().getTime();
      let initialBallZoomTime = 0;

      const transforms = {
        'STAGE0PRIZE0': {r: {x: .005, y: .005, z:.005}}, 
        'STAGE0PRIZE1': {r: {x: .005, y: .005, z:.005}}, 
        'STAGE0PRIZE2': {r: {x: .005, y: .005, z:.005}}, 
        'STAGE0PRIZE3': {r: {x: .005, y: .005, z:.005}},
        'STAGE0MAINSTRUCTURE': {r: {x: 0, y: 0, z:.001}},
        'STAGE0MINORSTRUCTURE': {r: {x: 0, y: 0, z:-.001}},
        'STAGE0MINORSTRUCTURE1': {r: {x: 0, y: 0, z:-.001}},
        'STAGE0MINORSTRUCTURE2': {r: {x: 0, y: 0, z:-.001}},
        'STAGE0MINORSTRUCTURE3': {r: {x: 0, y: 0, z:-.001}}
      }

      const activeTransforms = [
        'STAGE0PRIZE0', 
        'STAGE0PRIZE1', 
        'STAGE0PRIZE2', 
        'STAGE0PRIZE3', 
        'STAGE0MAINSTRUCTURE',
        'STAGE0MINORSTRUCTURE',
        'STAGE0MINORSTRUCTURE1',
        'STAGE0MINORSTRUCTURE2',
        'STAGE0MINORSTRUCTURE3'
      ]

      let currentTime = new Date().getTime();

      const initStage0 = () => {
        window.appConfig.stages.STAGE0.STAGE0PRIZE0 = scene.children.find((obj) => obj.name === "STAGE0PRIZE0")
        window.appConfig.stages.STAGE0.STAGE0PRIZE1 = scene.children.find((obj) => obj.name === "STAGE0PRIZE1")
        window.appConfig.stages.STAGE0.STAGE0PRIZE2 = scene.children.find((obj) => obj.name === "STAGE0PRIZE2")
        window.appConfig.stages.STAGE0.STAGE0PRIZE3 = scene.children.find((obj) => obj.name === "STAGE0PRIZE3")
        window.appConfig.stages.STAGE0.STAGE0MAINSTRUCTURE = scene.children.find((obj) => obj.name === "STAGE0MAINSTRUCTURE")
        window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE")
        window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE1 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE1")
        window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE2 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE2")
        window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE3 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE3")
        window.appConfig.stages.STAGE0.started = true
      }

      const timers = {
        initialBallZoom: () => {
          return {
            started: 0,
            ended: 0,
            z: scene.children.find((obj) => obj.gameName === "SPHERE0")
              .position.z,
            percentComplete: 0,
            time: 2000,
            timeLeft: 1000,
            currentTime: 0,
            name: 'INITIALBALLZOOM',
            id: Math.round(Math.random() * 10000),
            activeCallback: (percentComplete) => {
              window.appConfig.timers.data.initialBallZoom.percentComplete = percentComplete
            }
          }
        },
        stageReset: () => {
          return {
            started: 0,
            ended: 0,
            z: scene.children.find((obj) => obj.gameName === "SPHERE0")
              .position.z,
            percentComplete: 0,
            time: 2000,
            timeLeft: 1000,
            currentTime: 0,
            name: 'STAGERESET',
            id: Math.round(Math.random() * 10000),
            activeCallback: (percentComplete) => {
              window.appConfig.timers.data.stageReset.percentComplete = percentComplete
            },
            completedCallback: (percentComplete) => {
              window.appConfig.gameModeFunctions.start()
            }
          }
        },
        stageResultsBallZoom: () => {
          return {
            started: 0,
            ended: 0,
            z: scene.children.find((obj) => obj.gameName === "SPHERE0")
              .position.z,
            percentComplete: 0,
            time: 2000,
            timeLeft: 1000,
            currentTime: 0,
            id: Math.round(Math.random() * 10000),
            activeCallback: (percentComplete) => {
              window.appConfig.timers.data.stageResultsBallZoom.percentComplete = percentComplete
            }
          }
        },
        data: {
          initialBallZoom: {
            percentComplete: 0
          },
          stageReset: {
            percentComplete: 0
          },
          stageResultsBallZoom: {
            percentComplete: 0
          }
        },
        activeTimers: []
      }

      window.appConfig.timers = timers
      const appTimers = window.appConfig.timers
      render = function () {
        
        currentTime = new Date().getTime();

        if(!window.appConfig.stages.STAGE0.data.started) {
          initStage0()
        } else {
          activeTransforms.length > 0 && activeTransforms.forEach(t => {
            if(transforms[t].r && stages.STAGE0[t]) {
              stages.STAGE0[t].rotation.x += transforms[t].r.x
              stages.STAGE0[t].rotation.y += transforms[t].r.y
              stages.STAGE0[t].rotation.z += transforms[t].r.z
              stages.STAGE0[t].__dirtyRotation = true
            }
            if(transforms[t].t && stages.STAGE0[t]) {
              stages.STAGE0[t].position.x += transforms[t].t.x
              stages.STAGE0[t].position.y += transforms[t].t.y
              stages.STAGE0[t].position.z += transforms[t].t.z
              stages.STAGE0[t].__dirtyPosition = true
            }
            if(transforms[t].callback && stages.STAGE0[t]) {
              callback(t, transforms[t])
            }
          })
        }

        if(appTimers.activeTimers.length > 0) {
          let removeTimersArray = []
          appTimers.activeTimers.forEach((t, ti) => {
              if(appTimers.activeTimers[ti].started === 0) {
                appTimers.activeTimers[ti].started = currentTime
                appTimers.activeTimers[ti].currentTime = currentTime
                if(appTimers.activeTimers[ti].startedCallback) {
                    appTimers.activeTimers[ti].startedCallback(appTimers.activeTimers[ti].percentComplete)
                }
              }
              if(appTimers.activeTimers[ti].started !== 0 && appTimers.activeTimers[ti].ended === 0) {
                appTimers.activeTimers[ti].currentTime = currentTime
                appTimers.activeTimers[ti].percentComplete = (currentTime - appTimers.activeTimers[ti].started) / appTimers.activeTimers[ti].time;
                appTimers.activeTimers[ti].timeLeft = (currentTime - appTimers.activeTimers[ti].started)
                console.log("time left: " + appTimers.activeTimers[ti].timeLeft);
                console.log("% complete: " + appTimers.activeTimers[ti].percentComplete);
                if(appTimers.activeTimers[ti].activeCallback) {
                  appTimers.activeTimers[ti].activeCallback(appTimers.activeTimers[ti].percentComplete)
                }
                if (appTimers.activeTimers[ti].timeLeft > appTimers.activeTimers[ti].time) {
                  // end the timer --> this will make the first check not fire the function since ended has a value
                  appTimers.activeTimers[ti].ended = currentTime
                  console.log('timer ended: ', appTimers.activeTimers[ti]);
                  removeTimersArray.push(appTimers.activeTimers[ti].name)
                  if(appTimers.activeTimers[ti].completedCallback) {
                    appTimers.activeTimers[ti].completedCallback(appTimers.activeTimers[ti].percentComplete)
                  }
                }
              }
          })
          if(removeTimersArray.length > 0) {
            removeTimersArray.forEach(rt => {
              appTimers.activeTimers.forEach((at, ati) => {
                if(at.name === rt) {
                  appTimers.activeTimers.splice(ati, 1)
                }
              })
            })
          }
        }

        const sphere = scene.children.find((obj) => obj.gameName === "SPHERE0");
        const pointLight0 = scene.children
          .find((obj) => obj.gameName === "POINTLIGHT0")
        if (
          window.appConfig.start === false ||
          window.appConfig.pause === true
        ) {
          if (window.appConfig.start === false) {
            sphere.position.set(0, 10, 0);
          }
          sphere
            .setLinearVelocity(new THREE.Vector3(0, 0, 0));
        } else {
          if (
            window.appConfig.touchStart === true &&
            window.appConfig.touchEnd === false
          ) {
            console.log("ACTIVE!!!");
            const scaleV = 0.25;
            sphere
              .setLinearVelocity(
                new THREE.Vector3(
                  window.appConfig.diffX * scaleV,
                  window.appConfig.diffY * -scaleV,
                  0
                )
              );
          }
        }

        
          pointLight0.position.set(
            sphere.position.x,
            sphere.position.y + 1,
            sphere.position.z
          );

        const percentFinished = Math.abs(sphere.position.y) / 375;
        window.appConfig.percentFinished = percentFinished;
        if (currentTime % 10 < 3) {
          document.body.style.background =
            "linear-gradient(180deg, rgba(2,0,36,0) 0%, rgba(121,9,117,1) 0%, rgba(252,231,183,1) " +
            Math.round((1 - percentFinished) * 100) / 3 +
            "%, rgba(0,212,255,1)" +
            Math.round((1 - percentFinished) * 100) +
            "%)";
        }


        // camera positioning
        camera.position.x = sphere.position.x;
        camera.position.y = sphere.position.y;
        camera.position.z =
          10 + 
          90 * window.appConfig.timers.data.initialBallZoom.percentComplete -
          window.appConfig.timers.data.stageResultsBallZoom.percentComplete * 90 -
          window.appConfig.timers.data.stageReset.percentComplete * 5;

        if (window.appConfig.userHasEnded) {
          sphere
            .setLinearVelocity(new THREE.Vector3(0, 0, 0));
          sphere
            .setAngularVelocity(new THREE.Vector3(0, 0, 0));
        }

        let coinIndexToRemove = undefined;
          const potentiallyGrabbedCoin = window.appConfig.coins.find(
            (coin, coinIndex) => {
              coinIndexToRemove = coinIndex;
              return (
                Math.abs(coin.position.x - sphere.position.x) <
                  coin.scale.z * 2 &&
                Math.abs(coin.position.y - sphere.position.y) < coin.scale.z * 2
              );
            }
          );

          if (potentiallyGrabbedCoin) {
            const coinValue = potentiallyGrabbedCoin.coinValue
            const prizeValue  = potentiallyGrabbedCoin.prizeValue
            if (coinValue > 0) {
              window.appConfig.score.coins += potentiallyGrabbedCoin.coinValue;
              potentiallyGrabbedCoin.visible = false
              window.appConfig.coins.splice(coinIndexToRemove, 1);
              document.querySelector("#score").innerText =
                window.appConfig.score.coins;
            } else if (prizeValue > 0) {
              window.appConfig.userHasEnded = true
              window.appConfig.score.coins += potentiallyGrabbedCoin.prizeValue;
              window.appConfig.coins.splice(coinIndexToRemove, 1);
              document.querySelector("#score").innerText =
                window.appConfig.score.coins;

              //now start end of stage
              window.appConfig.timers.activeTimers.push(window.appConfig.timers.stageResultsBallZoom())
              window.appConfig.timer.pause();
              window.appConfig.results[`stage${window.appConfig.level}`]
                ? (window.appConfig.results[
                    `stage${window.appConfig.level}`
                  ].finalTime = window.appConfig.timer
                    .getTimeValues()
                    .toString(["minutes", "seconds", "secondTenths"]))
                : (window.appConfig.results[
                    `stage${window.appConfig.level}`
                  ] = {
                    finalTime: window.appConfig.timer
                      .getTimeValues()
                      .toString(["minutes", "seconds", "secondTenths"]),
                  });
              //now performance report and start level transition
              console.dir(window.appConfig.results);
              document.querySelector("#report-time").innerText =
                window.appConfig.results[
                  `stage${window.appConfig.level}`
                ].finalTime;
              document.querySelector("#report-coins").innerText =
                window.appConfig.score.coins;
              showHTMLElements(["report"]);
              centerElement({ id: "report", offsetTop: 0, offsetLeft: 0 });
              document.querySelector("#pause-button").disabled = true;
            }
          }

        requestAnimationFrame(render);
        renderer.render(scene, camera);
        render_stats.update();
      };

      window.appConfig.positionBall = (p) => {
        const sphere = scene.children.find((obj) => obj.gameName === "SPHERE0")
        sphere.position.x = p.x
        sphere.position.y = p.y
        sphere.position.z = p.z
        sphere.__dirtyPosition = true
      }

      window.appConfig.positionCamera = (p) => {
        const cam = scene.children.find((obj) => obj.type === "PerspectiveCamera")
        cam.position.x = p.x
        cam.position.y = p.y
        cam.position.z = p.z
        cam.__dirtyPosition = true
      }

      const start = () => {
        window.appConfig.userHasEnded = false
        window.appConfig.start = true;
        showHTMLElements(["pause-button", "game-scoreboard"]);
        // window.appConfig.initialBallZoom.userHasClickedStart = true;
        window.appConfig.timers.data.initialBallZoom.percentComplete = 0
        window.appConfig.timers.data.stageReset.percentComplete = 0
        window.appConfig.timers.data.stageResultsBallZoom.percentComplete = 0
        window.appConfig.timers.activeTimers.push(timers.initialBallZoom())
        window.appConfig.timer.start();
        document.querySelector("#pause-button").disabled = false;
        const theBall = scene.children.find(c => c.gameName === 'SPHERE0')
        theBall.position.set(window.appConfig.stages[window.appConfig.currentStage].data.startingPosition);
      };

      const pause = () => {
        window.appConfig.pause
          ? backgroundMusic0.play()
          : backgroundMusic0.pause();
        window.appConfig.pause = !window.appConfig.pause;
        if (window.appConfig.pause) {
          window.appConfig.timer.pause();
          showPauseMenu();
        } else {
          window.appConfig.timer.start();
          showGameMode();
        }
      };

      const reset = () => {
        window.appConfig.timers.activeTimers.push(window.appConfig.timers.stageReset())
        showHTMLElements([]);
        document.querySelector("#curtain").classList.remove("opacity-0");

        setTimeout(() => {
          document.querySelector("#curtain").classList.add("opacity-0");
          window.appConfig.positionBall(restartBallPosition)
          window.appConfig.positionCamera(restartBallPosition)        
        }, 2000);
        window.appConfig.timer.reset();
        window.appConfig.timer.pause();
        const restartBallPosition = window.appConfig.stages.STAGE0.data.startingPosition
      };

      window.appConfig.gameModeFunctions = {
        start: start,
        reset: reset,
        pause: pause
      }
      const showLevelSelect = () => {
        showHTMLElements(["level-select"]);
        centerElement({ id: "level-select", offsetTop: 0, offsetLeft: 0 });
      };
      const showSounds = () => {
        showHTMLElements(["sounds"]);
        centerElement({ id: "sounds", offsetTop: 0, offsetLeft: 0 });
      };
      const showCredits = () => {
        showHTMLElements(["credits-menu"]);
        centerElement({ id: "credits-menu", offsetTop: 0, offsetLeft: 0 });
      };
      const showStart = () => {
        showHTMLElements(["start-menu", "title", "start-button"]);
        centerElement({ id: "start-button", offsetTop: 0, offsetLeft: 0 });
        centerElement({ id: "title", offsetTop: -200, offsetLeft: 0 });
        centerElement({ id: "start-menu", offsetTop: 200, offsetLeft: 0 });
      };
      const showPauseMenu = () => {
        showHTMLElements(["pause-menu", "game-scoreboard"]);
        centerElement({ id: "pause-menu", offsetTop: 0, offsetLeft: 0 });
      };
      const showGameMode = () => {
        showHTMLElements(["pause-button", "game-scoreboard"]);
      };
      const goBack = () => {
        if (window.appConfig.pause) {
          showPauseMenu();
        } else {
          showStart();
        }
      };
      const centerElement = (options) => {
        const { id, offsetLeft, offsetTop } = options;
        const element = document.getElementById(id);
        const buttonHeight = element.offsetHeight;
        const buttonWidth = element.offsetWidth;
        const offsetHeight =
          window.innerHeight / 2 - buttonHeight / 2 + offsetTop;
        const offsetWidth =
          window.innerWidth / 2 - buttonWidth / 2 + offsetLeft;
        const root = document.documentElement;
        root.style.setProperty(`--${id}-offset-top`, offsetHeight + "px");
        root.style.setProperty(`--${id}-offset-left`, offsetWidth + "px");
      };
      const changeMusicVolume = (val) => {
        window.appConfig.backgroundMusics.forEach((m, mIndex) => {
          const currentVol = m.volume();
          m.fade(currentVol, val * 0.1 * 0.01, 1);
        });
      };
      const changeSFXVolume = (val) => {
        window.appConfig.howlSounds.forEach((m, mIndex) => {
          const currentVol = m.volume();
          m.fade(currentVol, val * 0.01, 1);
        });
      };
      const allElements = [
        "sounds",
        "start-menu",
        "pause-menu",
        "report",
        "level-select",
        "game-scoreboard",
        "title",
        "credits-menu",
        "start-button",
        "pause-button",
      ];
      const showHTMLElements = (elements) => {
        // elements is an array of id strings
        allElements.forEach((el) => {
          document.getElementById(el).classList.add("hide");
        });
        elements.forEach((el) => {
          document.getElementById(el).classList.remove("hide");
        });
      };
      const setLevel = (level) => {
        window.appConfig.level = level;
      };
      window.onload = initScene;
    </script>
  </head>

  <body>
    <div id="viewport"></div>
    <div id="game-scoreboard" class="hide">
      <div id="timer"></div>
      <div id="score"></div>
    </div>
    <div id="sounds" class="hide">
      <div id="sounds-title" class="menu-title-text">Sounds</div>

      <div class="menu-big-text">SFX</div>
      <input
        value="100"
        type="range"
        min="0"
        max="100"
        onmouseup="changeSFXVolume(this.value)"
        ontouchend="changeSFXVolume(this.value)"
      />
      <div class="menu-big-text">Music</div>
      <input
        value="100"
        type="range"
        min="0"
        max="100"
        onmouseup="changeMusicVolume(this.value)"
        ontouchend="changeMusicVolume(this.value)"
      />
      <button class="start-menu-button" onClick="goBack()">Back</button>
    </div>
    <div id="credits-menu" class="hide">
      <div id="credits-title" class="menu-title-text margin-bottom-2">Credits</div>
      <div class="margin-bottom-2">
        <div class="menu-big-text">Ian Lynch, Sean Lynch</div>
        <div class="menu-small-text">Programming Design</div>
      </div>
      <div class="margin-bottom-2">
        <div class="menu-big-text">Ian Lynch, Sean Lynch</div>
        <div class="menu-small-text">Programming Design</div>
      </div class="margin-bottom-2">
      <div>
        <div class="menu-big-text">Ian Lynch, Sean Lynch</div>
        <div class="menu-small-text">Programming Design</div>
      </div>
      <button class="start-menu-button" onClick="goBack()">Back</button>
    </div>
    <div id="report" class="hide">
      <table>
        <tr>
          <td>Time:</td>
          <td id="report-time"></td>
        </tr>
        <tr>
          <td>Crystals:</td>
          <td id="report-coins"></td>
        </tr>
        <tr>
          <td>Score:</td>
          <td id="report-score"></td>
        </tr>
      </table>
      <div id="report-options">
        <button
          id="report-level-select-button"
          class="start-menu-button"
          onClick="showLevelSelect()"
        >
          Level Select
        </button>
        <button
          id="report-reset-button"
          class="start-menu-button"
          onClick="reset({action:'reset'})"
        >
          Try Again
        </button>
        <button
          id="report-reset-button"
          class="start-menu-button"
          onClick="reset({action:'next'})"
        >
          Next Level
        </button>
      </div>
    </div>
    <div id="level-select" class="hide">
      <div id="level-select-title">Level Select</div>
      <table>
        <tr>
          <td class="level-select-button" onClick="setLevel(1)">1</td>
          <td class="level-select-button" onClick="setLevel(2)">2</td>
          <td class="level-select-button" onClick="setLevel(3)">3</td>
          <td class="level-select-button" onClick="setLevel(4)">4</td>
          <td class="level-select-button" onClick="setLevel(5)">5</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="setLevel(6)">6</td>
          <td class="level-select-button" onClick="setLevel(7)">7</td>
          <td class="level-select-button" onClick="setLevel(8)">8</td>
          <td class="level-select-button" onClick="setLevel(9)">9</td>
          <td class="level-select-button" onClick="setLevel(10)">10</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="setLevel(11)">11</td>
          <td class="level-select-button" onClick="setLevel(12)">12</td>
          <td class="level-select-button" onClick="setLevel(13)">13</td>
          <td class="level-select-button" onClick="setLevel(14)">14</td>
          <td class="level-select-button" onClick="setLevel(15)">15</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="setLevel(16)">16</td>
          <td class="level-select-button" onClick="setLevel(17)">17</td>
          <td class="level-select-button" onClick="setLevel(18)">18</td>
          <td class="level-select-button" onClick="setLevel(19)">19</td>
          <td class="level-select-button" onClick="setLevel(20)">20</td>
        </tr>
        <tr>
          <td class="level-select-button" onClick="setLevel(21)">21</td>
          <td class="level-select-button" onClick="setLevel(22)">22</td>
          <td class="level-select-button" onClick="setLevel(23)">23</td>
          <td class="level-select-button" onClick="setLevel(24)">24</td>
          <td class="level-select-button" onClick="setLevel(25)">25</td>
        </tr>
      </table>
      <button class="start-menu-button" onClick="goBack()">Back</button>
    </div>

    <div id="pause-menu" class="hide">
      <img
        src="images/pause.png"
        id="pause-menu-play-button"
        disabled
        onClick="pause()"
      />
      <button
        id="pause-level-select-button"
        class="start-menu-button"
        onClick="showLevelSelect()"
      >
        Level Select
      </button>
      <button
        id="pause-sounds-button"
        class="start-menu-button"
        onClick="showSounds()"
      >
        Sounds
      </button>
      <button
        id="pause-reset-button"
        class="start-menu-button"
        onClick="reset({action:'reset'})"
      >
        Restart Level
      </button>
    </div>
    <div id="title">BALLSINKI</div>
    <button id="start-button" onClick="start()">Start</button>
    <div id="start-menu">
      <button
        id="start-level-select-button"
        class="start-menu-button"
        onClick="showLevelSelect()"
      >
        Level Select
      </button>
      <button
        id="start-sounds-button"
        class="start-menu-button"
        onClick="showSounds()"
      >
        Sounds
      </button>
      <button
        id="start-credits-button"
        class="start-menu-button"
        onClick="showCredits()"
      >
        Credits
      </button>
    </div>
    <img
      src="images/pause.png"
      id="pause-button"
      disabled
      class="hide"
      onClick="pause()"
    />
    <div id="curtain"></div>
  </body>
  <script>
    // window.console.log = () => {}
    // window.console.warn = () => {}
    // window.console.dir = () => {}
  </script>
</html>
