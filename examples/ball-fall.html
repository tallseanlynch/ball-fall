<!DOCTYPE html>

<html>
  <head>
    <title>Ball Fall</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
      }
      html {
        touch-action: none;
      }
      /* body {
        background: rgb(2, 0, 36);
        background: linear-gradient(
          180deg,
          rgba(2, 0, 36, 0) 0%,
          rgba(121, 9, 117, 1) 0%,
          rgba(0, 212, 255, 1) 33%,
          rgba(252, 231, 183, 1) 66%
          rgba(2, 0, 36, 0) 100%
        );
      } */
    </style>

    <script type="text/javascript" src="js/ammo.js"></script>
    <script type="text/javascript" src="js/three-121.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="js/physi.js"></script>
    <script type="text/javascript" src="js/physijs_worker.js"></script>
    <script type="text/javascript" src="js/THREEOrbitControls.js"></script>
    <script type="text/javascript" src="js/easytimer.js"></script>
    <script type="text/javascript" src="js/howler.min.js"></script>
    <script src="https://unpkg.com/three@0.112.0/examples/js/loaders/GLTFLoader.js"></script>
    <script type="text/javascript">
      "use strict";

      var backgroundMusic0 = new Howl({
        src: ["sounds/BALL FALL jingle flat 1.mp3"],
        autoPlay: true,
        loop: false,
        onend: () => {
          console.log("finished 1");
        },
      });
      backgroundMusic0.volume(0.1);

      var howlSound0 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a1.mp3"],
        onstart: () => {
          console.log("started 0");
        },
        onend: () => {
          console.log("finished 0");
        },
      });

      var howlSound1 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a2.mp3"],
        onstart: () => {
          console.log("started 1");
        },
        onend: () => {
          console.log("finished 1");
        },
      });

      var howlSound2 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a3.mp3"],
        onstart: () => {
          console.log("started 2");
        },
        onend: () => {
          console.log("finished 2");
        },
      });

      var howlSound3 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a4.mp3"],
        onstart: () => {
          console.log("started 3");
        },
        onend: () => {
          console.log("finished 3");
        },
      });

      var howlSound4 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a5.mp3"],
        onstart: () => {
          console.log("started 4");
        },
        onend: () => {
          console.log("finished 4");
        },
      });

      var howlSound5 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a6.mp3"],
        onstart: () => {
          console.log("started 5");
        },
        onend: () => {
          console.log("finished 5");
        },
      });

      var howlSound6 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a7.mp3"],
        onstart: () => {
          console.log("started 6");
        },
        onend: () => {
          console.log("finished 6");
        },
      });

      var howlSound7 = new Howl({
        src: ["sounds/Sound FX/BALL FALL fx a8.mp3"],
        onstart: () => {
          console.log("started 7");
        },
        onend: () => {
          console.log("finished 7");
        },
      });

      backgroundMusic0.play();
      Physijs.scripts.worker = "js/physijs_worker.js";
      Physijs.scripts.ammo = "ammo.js";

      const basicColors = [
        new THREE.Color(0xfff1e3),
        new THREE.Color(0xffd5c9),
        new THREE.Color(0xffa6bb),
        new THREE.Color(0xff757f),
        new THREE.Color(0x159294),
      ];

      let adjustCamera = 20;

      const getRandomColor = () => {
        return basicColors[Math.floor(Math.random() * basicColors.length)];
      };

      var initScene,
        render,
        _boxes = [],
        spawnBox,
        loader,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground_material,
        ground,
        light,
        camera,
        orbitControls;

      initScene = function () {
        window.appConfig = {};
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.getElementById("viewport").appendChild(renderer.domElement);

        render_stats = new Stats();
        render_stats.domElement.style.position = "absolute";
        render_stats.domElement.style.top = "0px";
        render_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(render_stats.domElement);

        physics_stats = new Stats();
        physics_stats.domElement.style.position = "absolute";
        physics_stats.domElement.style.top = "50px";
        physics_stats.domElement.style.zIndex = 100;
        document
          .getElementById("viewport")
          .appendChild(physics_stats.domElement);

        scene = new Physijs.Scene();

        // scene.background = getRandomColor();
        scene.setGravity(new THREE.Vector3(0, -10, 0));

        scene.addEventListener("update", function () {
          scene.simulate(undefined, 1);
          physics_stats.update();
        });

        const skyColor = getRandomColor();
        const groundColor = getRandomColor();
        const hemisphereLight = new THREE.HemisphereLight(
          skyColor,
          groundColor,
          0.75
        );
        scene.add(hemisphereLight);

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );

        adjustCamera = 20;
        camera.position.set(0, 10, 10);
        // camera.lookAt(new THREE.Vector3(0, adjustCamera, 0));
        camera.lookAt(new THREE.Vector3(0, 10, 0));
        // sphere.position.set(0, 10, 0);
        // camera.lookAt(new THREE.Vector3(sphere.position.x, sphere.position.y + 10, sphere.position.z));
        // camera.lookAt(scene.position);
        scene.add(camera);

        // const cameraPositionTimer = new easytimer.Timer()

        // cameraPositionTimer.start({countdown: true, startValues: {seconds: 1}})
        // setTimeout(() => {
        //   console.log(cameraPositionTimer.getTotalTimeValues().seconds, cameraPositionTimer.getTotalTimeValues().seconds)
        // }, 5000)

        // Light
        light = new THREE.SpotLight(0xffffff);
        light.position.set(20, 80, 15);
        light.target.position.copy(scene.position);
        light.castShadow = true;
        light.shadowCameraLeft = -60;
        light.shadowCameraTop = -60;
        light.shadowCameraRight = 60;
        light.shadowCameraBottom = 60;
        light.shadowCameraNear = 20;
        light.shadowCameraFar = 200;
        light.shadowBias = -0.0001;
        light.shadowMapWidth = light.shadowMapHeight = 2048;
        light.shadowDarkness = 0.7;
        scene.add(light);

        const pointLight0 = new THREE.PointLight(getRandomColor(), 1);
        pointLight0.gameName = "POINTLIGHT0";
        pointLight0.power = 5;
        pointLight0.decay = 1;
        pointLight0.distance = 5;
        scene.add(pointLight0);

        // LFO
        const lfoPositive = (t = 1000) => {
          let lfoValue = (0.5 + 0.5 * Math.cos(Date.now() / t)) * 1;
          return lfoValue;
        };

        const lfo = (t = 1000) => {
          return (0.5 - lfoPositive(t)) * 2;
        };

        // Orbit Controls
        // orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        // orbitControls.enableRotate = false;

        //resize event handler
        function onWindowResize(event) {
          // remember these initial values
          var tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
          var windowHeight = window.innerHeight;
          camera.aspect = window.innerWidth / window.innerHeight;

          // adjust the FOV
          camera.fov =
            (360 / Math.PI) *
            Math.atan(tanFOV * (window.innerHeight / windowHeight));

          camera.updateProjectionMatrix();
          // camera.lookAt(scene.position);

          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.render(scene, camera);
        }
        onWindowResize();
        window.addEventListener("resize", onWindowResize, false);

        loader = new THREE.TextureLoader();

        let level = 25;
        window.appConfig.level = level;
        let score = {
          coins: 0,
        };
        window.appConfig.score = score;
        let features = [
          [
            { appearAtLevel: 16, type: "tetrahedron" },
            { appearAtLevel: 2, type: "cone" },
            { appearAtLevel: 11, type: "disc" },
            { appearAtLevel: 1, type: "ramp" },
            { appearAtLevel: 21, type: "torus" },
          ],
          [
            { appearAtLevel: 22, type: "torus" },
            { appearAtLevel: 6, type: "icosahedron" },
            { appearAtLevel: 1, type: "ramp" },
            { appearAtLevel: 12, type: "disc" },
            { appearAtLevel: 18, type: "tetrahedron" },
          ],
          [
            { appearAtLevel: 10, type: "icosahedron" },
            { appearAtLevel: 1, type: "ramp" },
            { appearAtLevel: 23, type: "torus" },
            { appearAtLevel: 3, type: "cone" },
            { appearAtLevel: 14, type: "disc" },
          ],
          [
            { appearAtLevel: 20, type: "cone" },
            { appearAtLevel: 19, type: "tetrahedron" },
            { appearAtLevel: 1, type: "ramp" },
            { appearAtLevel: 7, type: "icosahedron" },
            { appearAtLevel: 13, type: "disc" },
          ],
          [
            { appearAtLevel: 18, type: "tetrahedron" },
            { appearAtLevel: 5, type: "cone" },
            { appearAtLevel: 9, type: "icosahedron" },
            { appearAtLevel: 1, type: "ramp" },
            { appearAtLevel: 24, type: "torus" },
          ],
          [
            { appearAtLevel: 20, type: "tetrahedron" },
            { appearAtLevel: 8, type: "icosahedron" },
            { appearAtLevel: 1, type: "ramp" },
            { appearAtLevel: 15, type: "disc" },
            { appearAtLevel: 25, type: "ramp" },
          ],
          [
            { appearAtLevel: 14, type: "disc" },
            { appearAtLevel: 1, type: "ramp" },
            { appearAtLevel: 10, type: "icosahedron" },
            { appearAtLevel: 4, type: "cone" },
            { appearAtLevel: 17, type: "tetrahedron" },
          ],
          [
            { appearAtLevel: 9999, type: "plinko" },
            { appearAtLevel: 1, type: "plinko" },
            { appearAtLevel: 1, type: "plinko" },
            { appearAtLevel: 1, type: "plinko" },
            { appearAtLevel: 1, type: "plinko" },
          ],
        ];
        window.appConfig.features = features;
        const featureTypes = {
          ramp: [],
          cone: [],
          icosahedron: [],
          tetrahedron: [],
          torus: [],
          disc: [],
        };
        window.appConfig.featureTypes = featureTypes;
        const defaultYLanes = [16, 8, 0, -8, -16]; // to copy, splice, and then populate openSpots
        const openSpots = [];
        window.appConfig.openSpots = openSpots;
        const coins = [];
        window.appConfig.coins = coins;

        const populateFeatures = () => {
          features.forEach((row, rowIndex) => {
            const rowYLanes = [16, 8, 0, -8, -16];

            row.forEach((zone, zoneIndex) => {
              // console.log(zone);
              const xPercent = zoneIndex / row.length;
              const yPercent = rowIndex / features.length;
              const xPosition = xPercent * 25 - 12.5;
              const yLaneModIndex = Math.floor(
                Math.random() * rowYLanes.length
              );
              const yLaneMod = rowYLanes[yLaneModIndex];
              rowYLanes.splice(yLaneModIndex, 1);
              const yPosition =
                rowIndex !== 7
                  ? -(yPercent * 375) + yLaneMod
                  : -(yPercent * 375);

              if (rowIndex !== 7) {
                defaultYLanes.forEach((yLane, yLaneIndex) => {
                  if (yLane !== yLaneMod) {
                    const spot = {
                      xPosition: xPosition,
                      yPosition: -(yPercent * 375) + yLane,
                    };
                    openSpots.push(spot);
                  }
                });
              }
              // console.log("xPercent", xPercent);
              // console.log("yPercent", yPercent);
              // console.log("xPosition", xPosition);
              // console.log("yPosition", yPosition);
              // if (zone) {
              //   if (zone) {

              if (zone.appearAtLevel <= level) {
                if (zone.type === "ramp") {

                  // const tubeGeometry = new THREE.TubeBufferGeometry(new THREE.Path(tubeGeometryInfo.path.points), 4, 4, 4, tubeGeometryInfo.closed)

                  // instantiate a loader



                  // const obj = new Physijs.BoxMesh(
                  //   // new THREE.BoxGeometry(
                  //   //   Math.random() * 12 + 3,
                  //   //   Math.random() * 0.5 + 0.9,
                  //   //   Math.random() * 0.5 + 0.9
                  //   // ),
                  //   tubeGeometry,
                  //   Physijs.createMaterial(
                  //     new THREE.MeshPhongMaterial({ color: getRandomColor() }),
                  //     // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                  //     0.6, // medium friction
                  //     0.3 // low restitution
                  //   ),
                  //   0 // mass
                  // );
                  // console.dir(obj);
                  // zone.obj = obj;
                  // // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  // obj.position.x = xPosition + 2.5;
                  // obj.position.y = yPosition - 12;
                  // obj.position.z = 0;
                  // obj.__dirtyPosition = true;
                  // obj.position.__dirtyPosition = true;
                  // obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  // obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  // obj.castShadow = true;
                  // obj.receiveShadow = true;
                  // // obj.rotation.x = Math.random() * 2 * Math.PI;
                  // // obj.rotation.y = 0.3 * Math.PI;
                  // obj.rotation.z = Math.random() * 2 * Math.PI;
                  // obj.featureType = "BOX";
                  // scene.add(obj);
                  // console.dir(JSON.stringify(obj.position));
                } else if (zone.type === "plinko") {
                  const plinkoColor = getRandomColor();
                  const obj = new Physijs.BoxMesh(
                    new THREE.BoxGeometry(1, 10, 3),
                    Physijs.createMaterial(
                      new THREE.MeshPhongMaterial({ color: plinkoColor }),
                      // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                      0.6, // medium friction
                      0.3 // low restitution
                    ),
                    0 // mass
                  );
                  // console.dir(obj);
                  zone.obj = obj;
                  // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  obj.position.x = xPosition;
                  obj.position.y = yPosition + 10;
                  obj.position.z = 0;
                  obj.__dirtyPosition = true;
                  obj.position.__dirtyPosition = true;
                  obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  obj.castShadow = true;
                  obj.receiveShadow = true;
                  // obj.rotation.x = Math.random() * 2 * Math.PI;
                  // obj.rotation.y = 0.3 * Math.PI;
                  // obj.rotation.z = Math.random() * 2 * Math.PI;
                  obj.featureType = "PLINKO";
                  scene.add(obj);
                  const wall = new Physijs.BoxMesh(
                    new THREE.BoxGeometry(1, 3, 10),
                    Physijs.createMaterial(
                      new THREE.MeshPhongMaterial({ color: plinkoColor }),
                      // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                      0.6, // medium friction
                      0.3 // low restitution
                    ),
                    0 // mass
                  );
                  // console.dir(obj);
                  zone.wall = wall;
                  // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  wall.position.x = xPosition;
                  wall.position.y = yPosition + 3.5;
                  wall.position.z = 3.5;
                  wall.position.__dirtyPosition = true;
                  wall.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  wall.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  wall.castShadow = true;
                  wall.receiveShadow = true;
                  // obj.rotation.x = Math.random() * 2 * Math.PI;
                  // obj.rotation.y = 0.3 * Math.PI;
                  // obj.rotation.z = Math.random() * 2 * Math.PI;
                  wall.featureType = "PLINKOWALL";
                  // console.dir(JSON.stringify(obj.position));
                  scene.add(wall);
                } else if (zone.type === "cone") {
                  const obj = new Physijs.ConeMesh(
                    new THREE.CylinderGeometry(0, 4.75, 3.75, 32),
                    Physijs.createMaterial(
                      new THREE.MeshPhongMaterial({ color: getRandomColor() }),
                      // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                      0.6, // medium friction
                      0.3 // low restitution
                    ),
                    0 // mass
                  );
                  // console.dir(obj);
                  zone.obj = obj;
                  // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  obj.position.x = xPosition + 2.5;
                  obj.position.y = yPosition - 12;
                  obj.position.z = 0;
                  // obj.__dirtyPosition = true;
                  // obj.__dirtyRotation = true;
                  obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  obj.castShadow = true;
                  obj.receiveShadow = true;
                  obj.rotation.x = Math.random() * 2 * Math.PI;
                  obj.rotation.y = Math.random() * 2 * Math.PI;
                  obj.rotation.z = Math.random() * 2 * Math.PI;
                  obj.featureType = "CONE";
                  scene.add(obj);
                  // console.dir(JSON.stringify(obj.position));
                  console.dir(obj);
                  // debugger;
                } else if (zone.type === "icosahedron") {
                  const obj = new Physijs.ConvexMesh(
                    new THREE.IcosahedronGeometry(Math.random() * 3 + 1, 0),
                    Physijs.createMaterial(
                      new THREE.MeshPhongMaterial({ color: getRandomColor() }),
                      // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                      0.6, // medium friction
                      0.3 // low restitution
                    ),
                    0 // mass
                  );
                  // console.dir(obj);
                  zone.obj = obj;
                  // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  obj.position.x = xPosition + 2.5;
                  obj.position.y = yPosition - 12;
                  obj.position.z = 0;
                  obj.position.__dirtyPosition = true;
                  obj.rotation.__dirtyRotation = true;
                  obj.__dirtyPosition = true;
                  obj.__dirtyRotation = true;
                  obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  obj.castShadow = true;
                  obj.receiveShadow = true;
                  obj.rotation.x = Math.random() * 2 * Math.PI;
                  obj.rotation.y = Math.random() * 2 * Math.PI;
                  obj.rotation.z = Math.random() * 2 * Math.PI;
                  obj.featureType = "ICOSAHEDRON";
                  scene.add(obj);
                  // console.dir(JSON.stringify(obj.position));
                  console.dir(obj);
                  // debugger;
                } else if (zone.type === "disc") {
                  const radius = Math.random() * 3 + 1;
                  const obj = new Physijs.CylinderMesh(
                    new THREE.CylinderGeometry(
                      radius,
                      radius,
                      Math.random() * 3,
                      Math.ceil(Math.random() * 16 + 2)
                    ),
                    Physijs.createMaterial(
                      new THREE.MeshPhongMaterial({ color: getRandomColor() }),
                      // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                      0.6, // medium friction
                      0.3 // low restitution
                    ),
                    0 // mass
                  );
                  // console.dir(obj);
                  zone.obj = obj;
                  // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  obj.position.x = xPosition + 2.5;
                  obj.position.y = yPosition - 12;
                  obj.position.z = 0;
                  obj.position.__dirtyPosition = true;
                  obj.rotation.__dirtyRotation = true;
                  obj.__dirtyPosition = true;
                  obj.__dirtyRotation = true;
                  obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  obj.castShadow = true;
                  obj.receiveShadow = true;
                  obj.rotation.x = Math.random() * 2 * Math.PI;
                  obj.rotation.y = Math.random() * 2 * Math.PI;
                  obj.rotation.z = Math.random() * 2 * Math.PI;
                  obj.featureType = "DISC";
                  scene.add(obj);
                  // console.dir(JSON.stringify(obj.position));
                  console.dir(obj);
                  // debugger;
                } else if (zone.type === "tetrahedron") {
                  const radius = Math.random() * 3 + 1;
                  const obj = new Physijs.ConvexMesh(
                    new THREE.TetrahedronGeometry(Math.random() * 3 + 2),
                    Physijs.createMaterial(
                      new THREE.MeshPhongMaterial({ color: getRandomColor() }),
                      // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                      0.6, // medium friction
                      0.3 // low restitution
                    ),
                    0 // mass
                  );
                  // console.dir(obj);
                  zone.obj = obj;
                  // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  obj.position.x = xPosition + 2.5;
                  obj.position.y = yPosition - 12;
                  obj.position.z = 0;
                  obj.position.__dirtyPosition = true;
                  obj.rotation.__dirtyRotation = true;
                  obj.__dirtyPosition = true;
                  obj.__dirtyRotation = true;
                  obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  obj.castShadow = true;
                  obj.receiveShadow = true;
                  obj.rotation.x = Math.random() * 2 * Math.PI;
                  obj.rotation.y = Math.random() * 2 * Math.PI;
                  obj.rotation.z = Math.random() * 2 * Math.PI;
                  obj.featureType = "TETRAHEDRON";
                  scene.add(obj);
                  // console.dir(JSON.stringify(obj.position));
                  console.dir(obj);
                  // debugger;
                } else if (zone.type === "torus") {
                  const radiusMod = Math.random() * 3 + 1;
                  const obj = new Physijs.ConvexMesh(
                    new THREE.TorusGeometry(
                      Math.random() + 1,
                      0.2,
                      6,
                      Math.random() > 0.5 ? 4 : 5
                    ),
                    Physijs.createMaterial(
                      new THREE.MeshPhongMaterial({ color: getRandomColor() }),
                      // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
                      0.6, // medium friction
                      0.3 // low restitution
                    ),
                    0 // mass
                  );
                  // console.dir(obj);
                  zone.obj = obj;
                  // obj.position.set(new THREE.Vector3(xPosition, yPosition, 0));

                  obj.position.x = xPosition + 2.5;
                  obj.position.y = yPosition - 12;
                  obj.position.z = 0;
                  obj.position.__dirtyPosition = true;
                  obj.rotation.__dirtyRotation = true;
                  obj.__dirtyPosition = true;
                  obj.__dirtyRotation = true;
                  obj.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  obj.setAngularVelocity(new THREE.Vector3(0, 0, 0));
                  obj.castShadow = true;
                  obj.receiveShadow = true;
                  obj.rotation.x = Math.random() * 2 * Math.PI;
                  obj.rotation.y = Math.random() * 2 * Math.PI;
                  obj.rotation.z = Math.random() * 2 * Math.PI;
                  obj.featureType = "TORUS";
                  scene.add(obj);
                  // console.dir(JSON.stringify(obj.position));
                  console.dir(obj);
                  // debugger;
                }
                zone.obj && Object.keys(featureTypes).indexOf(zone.type) > -1
                  ? featureTypes[zone.type].push(zone.obj)
                  : null;
              }
            });
          });
        };

        populateFeatures();

        const createBeam = (config) => {
          const beam0 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(10 * config.s, 2, 2),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({ color: 0xffffff }),
            // new THREE.MeshPhongMaterial({ color: getRandomColor() }),
            // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
            0.6, // medium friction
            0.3 // low restitution
          ),
          0 // mass
          );
          const beam0cap0 = new Physijs.BoxMesh(
            new THREE.BoxGeometry(1.45, 2, 1.45),
            Physijs.createMaterial(
              // new THREE.MeshPhongMaterial({ color: getRandomColor() }),
              new THREE.MeshPhongMaterial({ color: 0xffffff }),
              // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          const beam0cap1 = new Physijs.BoxMesh(
            new THREE.BoxGeometry(1.45, 2, 1.45),
            Physijs.createMaterial(
              // new THREE.MeshPhongMaterial({ color: getRandomColor() }),
              new THREE.MeshPhongMaterial({ color: 0xffffff }),
              // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
              0.6, // medium friction
              0.3 // low restitution
            ),
            0 // mass
          );
          beam0cap0.rotation.y = .25 * Math.PI
          beam0cap0.position.x = -5 * config.s
          beam0.add(beam0cap0)
          beam0cap1.rotation.y = .25 * Math.PI
          beam0cap1.position.x = 5 * config.s
          beam0.add(beam0cap1)
          beam0.position.set(config.p[0], config.p[1], config.p[2])
          beam0.rotation.set(config.r[0], config.r[1], config.r[2])
          return beam0
        }

        const vAdj = -70
        const sAdj = 3
        const stage0 = {
          beams: [
            // diamond shape
            // createBeam({p: [-19.5,15,0], r: [0,0, .25 * Math.PI], s: 5}),
            // createBeam({p: [19.5,15,0], r: [0,0, -.25 * Math.PI], s: 5}),
            // createBeam({p: [-19.5,-24,0], r: [0,0, -.25 * Math.PI], s: 5}),
            // createBeam({p: [19.5,-24,0], r: [0,0, .25 * Math.PI], s: 5}),
            // diamond shape
            createBeam({p: [-19.5 * sAdj, 15 * sAdj, 0 * sAdj], r: [0,0, .25 * Math.PI], s: 5.35 * sAdj}),
            createBeam({p: [19.5 * sAdj,15 * sAdj,0 * sAdj], r: [0,0, -.25 * Math.PI], s: 5.35 * sAdj}),
            createBeam({p: [-19.5 * sAdj,-24 * sAdj,0 * sAdj], r: [0,0, -.25 * Math.PI], s: 5.35 * sAdj}),
            createBeam({p: [19.5 * sAdj,-24 * sAdj,0 * sAdj], r: [0,0, .25 * Math.PI], s: 5.35 * sAdj}),
            createBeam({p: [-19.5,15,0], r: [0,0, .25 * Math.PI], s: 5}),
            createBeam({p: [19.5,15,0], r: [0,0, -.25 * Math.PI], s: 5}),
            createBeam({p: [-21.5,-22,0], r: [0,0, -.25 * Math.PI], s: 4.5}),
            createBeam({p: [21.5,-22,0], r: [0,0, .25 * Math.PI], s: 4.5}),
            createBeam({p: [0,-5,0], r: [0,0,0], s: 1}),
            createBeam({p: [-19.5,5+vAdj,0], r: [0,0, .25 * Math.PI], s: 2}),
            createBeam({p: [19.5,5+vAdj,0], r: [0,0, -.25 * Math.PI], s: 2}),
            createBeam({p: [-21.5,-22+vAdj,0], r: [0,0, -.25 * Math.PI], s: 2}),
            createBeam({p: [21.5,-22+vAdj,0], r: [0,0, .25 * Math.PI], s: 2}),
            createBeam({p: [0,-5+vAdj,0], r: [0,0,0], s: 1}),
            // createBeam({p: [0,-15,0], r: [0,0,0], s: 1}),
            // createBeam({p: [0,-25,0], r: [0,0,0], s: 1}),
            // createBeam({p: [0,-35,0], r: [0,0,0], s: 1}),
            // createBeam({p: [0,-45,0], r: [0,0,0], s: 1}),
            // createBeam({p: [0,-55,0], r: [0,0,0], s: 1}),
            // createBeam({p: [0,-65,0], r: [0,0,0], s: 1}),
            // createBeam({p: [0,-75,0], r: [0,0,0], s: 1}),
          ]
        }

        stage0.beams.forEach((beam) => {
          scene.add(beam)
        })
          



        // loader.load("models/scene.gltf", (root) => {
        //   //now make as physijs
        //   const shart = root.scene;
        //   shart.scale.set(10, 10, 10);
        //   scene.add(shart);
        // });

        //SAVE THIS TO SHOW HOW TO LOAD TEXTURES
        // const coinSpriteMap = new THREE.TextureLoader().load(
        //   "images/circle-16.png"
        // );
        // const coinSpriteMaterial = new THREE.SpriteMaterial({
        //   map: coinSpriteMap,
        //   color: 0xffffff,
        // });

        const populateCoins = () => {
          let doubleCoinsLeft = 20;
          let tripleCoinsLeft = 20;

          const tripleHex = 0x159294;
          const doubleHex = 0xffa6bb;
          const singleHex = 0xffd5c9;
          const tripleScale = 2;
          const doubleScale = 1.5;
          const singleScale = 1;
          const xScaleMod = 0.5;
          const yScaleMod = 1;
          const zScaleMod = 0.5;

          const crystalMaterialOptions = {
            color: 0x000000,
            emissive: 0xffffff,
            transparent: true,
            opacity: 0.85,
            shininess: 150,
            roughness: 0.2,
            metalness: 0.2,
          };

          for (let i = 0; i < 60; i++) {
            const randomIndex = Math.floor(Math.random() * openSpots.length);
            const coin = new THREE.Mesh();
            const crystalTop = new THREE.Mesh(
              new THREE.CylinderGeometry(0, 1, 0.5, 6),
              // new THREE.MeshStandardMaterial(crystalMaterialOptions)
              new THREE.MeshPhongMaterial()
            );
            crystalTop.translateY(0.75);
            const crystalMiddle = new THREE.Mesh(
              new THREE.CylinderGeometry(1, 1, 1, 6),
              // new THREE.MeshStandardMaterial(crystalMaterialOptions)
              new THREE.MeshPhongMaterial()
            );

            const crystalBottom = new THREE.Mesh(
              new THREE.CylinderGeometry(1, 0, 0.5, 6),
              // new THREE.MeshStandardMaterial(crystalMaterialOptions)
              new THREE.MeshPhongMaterial()
            );
            crystalBottom.translateY(-0.75);
            coin.add(crystalTop);
            coin.add(crystalMiddle);
            coin.add(crystalBottom);
            // const coin = new THREE.Mesh(
            //   new THREE.BoxGeometry(1, 1, 0.1),
            //   new THREE.MeshStandardMaterial({
            //     color: 0x000000,
            //     emissive: 0xffffff,
            //     transparent: true,
            //     opacity: 0.85,
            //     shininess: 150,
            //     roughness: 0.2,
            //     metalness: 0.2,
            //   })
            // );
            // coin.geometry.applyMatrix(
            //   new THREE.Matrix4().makeRotationFromEuler(
            //     new THREE.Euler(0, Math.PI * 0.25, Math.PI * 0.25)
            //   )
            // );
            coin.position.set(
              openSpots[randomIndex].xPosition + 2.5 + (Math.random() * 2 - 1),
              openSpots[randomIndex].yPosition -
                12.5 +
                (Math.random() * 3 - 1.5),
              0
            );
            openSpots.splice(randomIndex, 1);
            coin.featureType = "COIN";
            if (tripleCoinsLeft > 0) {
              coin.scale.set(
                tripleScale * xScaleMod,
                tripleScale * yScaleMod,
                tripleScale * zScaleMod
              );
              coin.coinType = "triple";
              coin.coinValue = 3;
              // coin.material.color.setHex(tripleHex);
              coin.children.forEach((child) => {
                child.material.color.setHex(tripleHex);
              });
              tripleCoinsLeft--;
            } else if (doubleCoinsLeft > 0) {
              coin.scale.set(
                doubleScale * xScaleMod,
                doubleScale * yScaleMod,
                doubleScale * zScaleMod
              );
              coin.coinType = "double";
              coin.coinValue = 2;
              // coin.material.color.setHex(doubleHex);
              coin.children.forEach((child) => {
                child.material.color.setHex(doubleHex);
              });
              doubleCoinsLeft--;
            } else {
              coin.scale.set(
                singleScale * xScaleMod,
                singleScale * yScaleMod,
                singleScale * zScaleMod
              );
              coin.coinType = "single";
              coin.coinValue = 1;
              // coin.material.color.setHex(singleHex);
              coin.children.forEach((child) => {
                child.material.color.setHex(singleHex);
              });
            }
            // coin.rotation.z = Math.PI * 0.25;
            scene.add(coin);
            coins.push(coin);
          }
        };
        populateCoins();
        spawnBox();

        requestAnimationFrame(render);
        scene.simulate();
        const clickRay = new THREE.Raycaster();

        // const initialCameraPosition = camera.position.z
        // const cameraPositionTimer = new easytimer.Timer({ countdown: true, startValues: {seconds: 2}});
        // cameraPositionTimer.addEventListener("secondTenthsUpdated", function () {
        //   console.log(cameraPositionTimer.getTimeValues().toString(['minutes', 'seconds', 'secondTenths']))
        //   camera.position.z += 1
        // });

        // window.cameraPositionTimer = cameraPositionTimer
        // const initialCameraTimeout = setTimeout(() => {
        //   cameraPositionTimer.start({precision: 'secondTenths'})
        // }, 1000)

        const timer = new easytimer.Timer({ precision: "secondTenths" });
        timer.addEventListener("secondTenthsUpdated", function (e) {
          document.querySelector(
            "#timer"
          ).innerText = `${timer
            .getTimeValues()
            .toString(["minutes", "seconds", "secondTenths"])}`;
        });
        const results = {};
        window.appConfig = {
          ...window.appConfig,
          touchStart: false,
          touchEnd: false,
          currentX: 0,
          currentY: 0,
          prevX: 0,
          prevY: 0,
          diffX: 0,
          diffY: 0,
          start: false,
          pause: false,
          timer: timer,
          results: results,
          pause: false,
        };

        document.addEventListener("touchstart", (e) => {
          if (!window.appConfig.stageResultsBallZoom.userHasEnded) {
            window.appConfig.touchEnd = false;
            window.appConfig.touchStart = true;
            window.appConfig.currentX = e.touches[0].clientX;
            window.appConfig.currentY = e.touches[0].clientY;

            window.appConfig.prevX = e.touches[0].clientX;
            window.appConfig.prevY = e.touches[0].clientY;
            window.appConfig.diffX =
              window.appConfig.currentX - window.appConfig.prevX;
            window.appConfig.diffY =
              window.appConfig.currentY - window.appConfig.prevY;
            console.log("TOUCHSTART", e);
            console.log("APPCONFIG", window.appConfig);
          }
        });
        // document.addEventListener('mousemove', (e) => {
        // 	console.log('MOUSEMOVE', e.clientX, e.clientY)
        // })
        document.body.addEventListener(
          "touchmove",
          (e) => {
            if (!window.appConfig.stageResultsBallZoom.userHasEnded) {
              window.appConfig.prevX = window.appConfig.currentX;
              window.appConfig.prevY = window.appConfig.currentY;
              window.appConfig.currentX = e.touches[0].clientX;
              window.appConfig.currentY = e.touches[0].clientY;
              window.appConfig.diffX =
                e.touches[0].clientX - window.appConfig.prevX;
              window.appConfig.diffY =
                e.touches[0].clientY - window.appConfig.prevY;
              console.log(
                "TOUCHMOVE",
                e.touches[0].clientX,
                e.touches[0].clientY
              );
              console.log("APPCONFIG", window.appConfig);
              console.log(window.appConfig.diffX, window.appConfig.diffY);
              e.preventDefault();
            }
          },
          true
        );
        document.addEventListener("touchend", (e) => {
          if (!window.appConfig.stageResultsBallZoom.userHasEnded) {
            window.appConfig.touchEnd = true;
            window.appConfig.touchStart = false;
            window.appConfig.currentX = 0;
            window.appConfig.currentY = 0;
            window.appConfig.diffX = 0;
            window.appConfig.diffY = 0;
            console.log("TOUCHEND", e);
            console.log("APPCONFIG", window.appConfig);
          }
        });
        document.addEventListener("click", (e) => {
          e.preventDefault();
          console.log("CLICK", e);
          const normalized = new THREE.Vector2(e.clientX, e.clientY);
          clickRay.setFromCamera(normalized.normalize(), camera);

          console.log(
            clickRay.intersectObject(
              scene.children.find((obj) => obj.gameName === "FRONTGLASS")
            )
          );
          console.log("APPCONFIG", window.appConfig);
        });

        document.querySelector("#curtain").classList.add("opacity-0");
      };

      spawnBox = (function () {
        var box_geometry = new THREE.BoxGeometry(4, 4, 4),
          sphere_geometry = new THREE.SphereGeometry(1, 16, 16),
          handleCollision = function (
            collided_with,
            linearVelocity,
            angularVelocity
          ) {
            console.log("collision");
            console.log("collided_with", collided_with);
            if (collided_with.featureType === "STAGEFLOOR") {
              window.appConfig.stageResultsBallZoom.userHasEnded = true;
              window.appConfig.timer.pause();
              window.appConfig.results[`stage${window.appConfig.level}`]
                ? (window.appConfig.results[
                    `stage${window.appConfig.level}`
                  ].finalTime = window.appConfig.timer
                    .getTimeValues()
                    .toString(["minutes", "seconds", "secondTenths"]))
                : (window.appConfig.results[
                    `stage${window.appConfig.level}`
                  ] = {
                    finalTime: window.appConfig.timer
                      .getTimeValues()
                      .toString(["minutes", "seconds", "secondTenths"]),
                  });
              //now performance report and start level transition
              console.dir(window.appConfig.results);
              document.querySelector("#report #time").innerText =
                window.appConfig.results[
                  `stage${window.appConfig.level}`
                ].finalTime;
              document.querySelector("#report #coins").innerText =
                window.appConfig.score.coins;
              document.querySelector("#report").classList.remove("hide");
              document.querySelector("#pause-button").disabled = true;
            }
            const suonousFeatureTypes = [
              "BOX",
              "ICOSAHEDRON",
              "SIDEGLASS",
              // "STAGEFLOOR",
              "TETRAHEDRON",
              "CONE",
              "DISC",
              "TORUS",
              "PLINKO",
              "COIN",
            ];
            if (suonousFeatureTypes.indexOf(collided_with.featureType) > -1) {
              switch (++this.collisions % 8) {
                case 1:
                  howlSound0.play();
                  break;

                case 2:
                  howlSound1.play();
                  break;

                case 3:
                  howlSound2.play();
                  break;

                case 4:
                  howlSound3.play();
                  break;

                case 5:
                  howlSound4.play();
                  break;

                case 6:
                  howlSound5.play();
                  break;

                case 7:
                  howlSound6.play();
                  break;

                case 8:
                  howlSound7.play();
                  break;
              }
              console.log("AFTERPLAY");
            }
          },
          createBox = function () {
            var box, material;

            material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial(),
              // new THREE.MeshLambertMaterial({ map: loader.load( 'images/plywood.jpg' ) }),
              0.6, // medium friction
              0.3 // low restitution
            );

            //material = new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) });

            box = new Physijs.BoxMesh(box_geometry, material);
            box.collisions = 0;

            box.position.set(
              Math.random() * 15 - 7.5,
              25,
              Math.random() * 15 - 7.5
            );

            box.rotation.set(
              Math.random() * Math.PI,
              Math.random() * Math.PI,
              Math.random() * Math.PI
            );

            box.castShadow = true;
            // box.addEventListener("collision", handleCollision);
            box.addEventListener("ready", spawnBox);
            scene.add(box);
          };

        let createSphere = function () {
          var sphere, material;

          material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
              color: getRandomColor(),
              // envMap: scene.background,
              // combine: THREE.MixOperation,
              // reflectivity: 0.1,
              // transparent: true,
              // opacity: 0.98
            }),
            0.5, // medium friction
            3 // low restitution
          );
          sphere = new Physijs.SphereMesh(sphere_geometry, material);
          sphere.collisions = 0;

          sphere.position.set(0, 0, 0);

          sphere.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );

          sphere.castShadow = true;
          sphere.addEventListener("collision", handleCollision);
          sphere.gameName = "SPHERE0";
          scene.add(sphere);
        };
        return () => {
          createSphere();

          const sidesColor = getRandomColor();

          const glassMesh0 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(500, 370, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0,
              transparent: true,
              wifeframe: true,
            }),
            /*mass*/ 0
          );
          glassMesh0.gameName = "FRONTGLASS";
          glassMesh0.name = "glassMesh0";

          const glassMesh1 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(500, 375, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0.0,
              transparent: true,
              wifeframe: true,
            }),
            /*mass*/ 0
          );
          glassMesh1.gameName = "BACKGLASS";
          glassMesh1.name = "glassMesh1";

          // const sideGlassMaterial = Physijs.createMaterial(
          //   new THREE.MeshBasicMaterial({
          //     color: sidesColor,
          //     opacity: 0.5,
          //     transparent: true,
          //   }),
          //   0.8,
          //   0.4
          // );

          // const glassMesh2 = new Physijs.BoxMesh(
          //   /*geometry*/ new THREE.BoxGeometry(3, 375, 1),
          //   /*material*/ Physijs.createMaterial(
          //     new THREE.MeshBasicMaterial({
          //       color: sidesColor,
          //       opacity: 0.5,
          //       transparent: true,
          //     }),
          //     0.8,
          //     0.4
          //   ),
          //   /*mass*/ 0,
          //   { restitution: 0.2 }
          // );
          // glassMesh2.gameName = "LEFTGLASS";
          // glassMesh2.name = "glassMesh2";
          // glassMesh2.featureType = "SIDEGLASS";

          // const glassMesh3 = new Physijs.BoxMesh(
          //   /*geometry*/ new THREE.BoxGeometry(3, 375, 1),
          //   /*material*/ Physijs.createMaterial(
          //     new THREE.MeshBasicMaterial({
          //       color: sidesColor,
          //       opacity: 0.5,
          //       transparent: true,
          //     }),
          //     0.8,
          //     0.4
          //   ),
          //   /*mass*/ 0,
          //   { restitution: 1 }
          // );
          // glassMesh3.gameName = "RIGHTGLASS";
          // glassMesh3.name = "glassMesh3";
          // glassMesh3.featureType = "SIDEGLASS";
          const stageFloor = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(25, 1, 10),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0,
              transparent: true,
            }),
            /*mass*/ 0
          );

          stageFloor.name = "stageFloor";
          stageFloor.featureType = "STAGEFLOOR";
          const catchWall = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(25, 10, 1),
            /*material*/ new THREE.MeshBasicMaterial({
              color: getRandomColor(),
              opacity: 0,
              transparent: true,
            }),
            /*mass*/ 0
          );

          catchWall.name = "catchWall";
          catchWall.featureType = "CATCHWALL";

          catchWall.position.y = -327;
          catchWall.position.z = 5;
          glassMesh0.position.z = 1.5;
          glassMesh1.position.z = -1.5;
          // glassMesh2.position.x = -12.5;
          // glassMesh2.rotation.y = Math.PI * 0.5;
          // glassMesh3.position.x = 12.5;
          // glassMesh3.rotation.y = Math.PI * -0.5;
          glassMesh0.position.y = -137.5;
          glassMesh1.position.y = -140;
          // glassMesh2.position.y = -140;
          // glassMesh3.position.y = -140;
          stageFloor.position.y = -327;
          stageFloor.rotation.x = Math.PI * 0.125;
          glassMesh0.__dirtyPosition = true;
          glassMesh0.__dirtyRotation = true;
          glassMesh1.__dirtyPosition = true;
          glassMesh1.__dirtyRotation = true;
          // glassMesh2.__dirtyPosition = true;
          // glassMesh2.__dirtyRotation = true;
          // glassMesh3.__dirtyPosition = true;
          // glassMesh3.__dirtyRotation = true;

          scene.add(glassMesh0);
          scene.add(glassMesh1);
          // scene.add(glassMesh2);
          // scene.add(glassMesh3);
          scene.add(stageFloor);
          scene.add(catchWall);

          // const loader = new THREE.BufferGeometryLoader();

          // // load a resource
          // loader.load(
          //   // resource URL
          //   'geometries/geometry.json',

          //   // onLoad callback
          //   function ( geometry ) {

          //     const obj = new Physijs.BoxMesh(
          //       geometry,
          //       Physijs.createMaterial(
          //           new THREE.MeshPhongMaterial({ color: getRandomColor() }),
          //           0.6, // medium friction
          //           0.3 // low restitution
          //         ),
          //         0 // mass
          //     );

          //     scene.add( obj );
          //   },

          //   // onProgress callback
          //   function ( xhr ) {
          //     console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
          //   },

          //   // onError callback
          //   function ( err ) {
          //     console.log( 'An error happened' );
          //   }
          // );

          // const geoTest = () => {
          //   const length = 12, width = 8;

          //   const shape = new THREE.Shape();
          //   const start = new THREE.Vector2(0,-10)
          //   const end = new THREE.Vector2(0,0)
          //   shape.setFromPoints([start, end])
          //   // shape.moveTo( 0,0 );
          //   // shape.lineTo( 0, width );
          //   // shape.lineTo( length, width );
          //   // shape.lineTo( length, 0 );
          //   // shape.lineTo( 0, 0 );

          //   const extrudeSettings = {
          //     steps: 1,
          //     // depth: 16,
          //     // depth: 1,
          //     // bevelEnabled: true,
          //     // bevelThickness: 1,
          //     // bevelSize: 1,
          //     // bevelOffset: 0,
          //     // bevelSegments: 1
          //   };

          //   const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
          //   const material = new THREE.MeshPhongMaterial( { color: 0xffffff } );
          //   const mesh = new THREE.Mesh( geometry, material ) ;
          //   mesh.position.z = -25
          //   mesh.rotation.y = .5 * Math.PI
          //   scene.add( mesh );
          // }
          // geoTest()


          window.appConfig.initialBallZoomReset = () => {
            window.appConfig.initialBallZoom = {
              userHasClickedStart: false,
              started: 0,
              ended: 0,
              z: scene.children.find((obj) => obj.gameName === "SPHERE0")
                .position.z,
              percentComplete: 0,
              time: 2000,
              timeLeft: 1000,
              currentTime: 0,
            };
          };

          window.appConfig.stageResultsBallZoomReset = () => {
            window.appConfig.stageResultsBallZoom = {
              userHasEnded: false,
              started: 0,
              ended: 0,
              z: scene.children.find((obj) => obj.gameName === "SPHERE0")
                .position.z,
              percentComplete: 0,
              time: 2000,
              timeLeft: 1000,
              currentTime: 0,
            };
          };

          window.appConfig.stageResetReset = () => {
            window.appConfig.stageReset = {
              userHasEndedReport: false,
              started: 0,
              ended: 0,
              z: scene.children.find((obj) => obj.gameName === "SPHERE0")
                .position.z,
              percentComplete: 0,
              time: 2000,
              timeLeft: 1000,
              currentTime: 0,
            };
          };

          window.appConfig.initialBallZoomReset();
          window.appConfig.stageResultsBallZoomReset();
          window.appConfig.stageResetReset();
        };
      })();

      let appStartTime = new Date().getTime();
      let initialBallZoomTime = 0;

      render = function () {
        if (
          window.appConfig.stageReset.userHasEndedReport &&
          window.appConfig.stageReset.started === 0 &&
          window.appConfig.stageReset.ended === 0
        ) {
          window.appConfig.stageReset.started = new Date().getTime();
          window.appConfig.stageReset.currentTime = new Date().getTime();
        }

        if (
          window.appConfig.stageReset.started !== 0 &&
          window.appConfig.stageReset.ended === 0
        ) {
          let currentTime = new Date().getTime();
          window.appConfig.stageReset.currentTime = currentTime;
          let percentComplete =
            (currentTime - window.appConfig.stageReset.started) /
            window.appConfig.stageReset.time;
          window.appConfig.stageReset.percentComplete = percentComplete;
          console.log(
            "time left: " + (currentTime - window.appConfig.stageReset.started)
          );
          console.log("time left %: " + percentComplete);
          let mesh = scene.children.find((obj) => obj.gameName === "SPHERE0");
          if (
            currentTime - window.appConfig.stageReset.started >
            window.appConfig.stageReset.time
          ) {
            window.appConfig.stageReset.ended = new Date().getTime();
            mesh.position.set(0, 0, 0);
            mesh.__dirtyPosition = true;
            camera.position.set(0, 10, 10);
            camera.lookAt(new THREE.Vector3(0, 10, 0));
            document.querySelector("#start-button").classList.remove("hide");
            document.querySelector("#report").classList.add("hide");
            window.appConfig.start = false;
            window.appConfig.stageResultsBallZoomReset();
            window.appConfig.initialBallZoomReset();
            window.appConfig.stageResetReset();
          }
        }

        if (
          window.appConfig.stageResultsBallZoom.userHasEnded &&
          window.appConfig.stageResultsBallZoom.started === 0 &&
          window.appConfig.stageResultsBallZoom.ended === 0
        ) {
          window.appConfig.stageResultsBallZoom.started = new Date().getTime();
          window.appConfig.stageResultsBallZoom.currentTime = new Date().getTime();
        }

        if (
          window.appConfig.stageResultsBallZoom.started !== 0 &&
          window.appConfig.stageResultsBallZoom.ended === 0
        ) {
          let currentTime = new Date().getTime();
          window.appConfig.stageResultsBallZoom.currentTime = currentTime;
          let percentComplete =
            (currentTime - window.appConfig.stageResultsBallZoom.started) /
            window.appConfig.stageResultsBallZoom.time;
          window.appConfig.stageResultsBallZoom.percentComplete = percentComplete;
          console.log(
            "time left: " +
              (currentTime - window.appConfig.stageResultsBallZoom.started)
          );
          console.log("time left %: " + percentComplete);
          if (
            currentTime - window.appConfig.stageResultsBallZoom.started >
            window.appConfig.stageResultsBallZoom.time
          ) {
            window.appConfig.stageResultsBallZoom.ended = new Date().getTime();
            console.log(appConfig.stageResultsBallZoom);
          }
        }

        if (
          window.appConfig.initialBallZoom.userHasClickedStart &&
          window.appConfig.initialBallZoom.started === 0 &&
          window.appConfig.initialBallZoom.ended === 0
        ) {
          window.appConfig.initialBallZoom.started = new Date().getTime();
          window.appConfig.initialBallZoom.currentTime = new Date().getTime();
        }

        if (
          window.appConfig.initialBallZoom.started !== 0 &&
          window.appConfig.initialBallZoom.ended === 0
        ) {
          let currentTime = new Date().getTime();
          window.appConfig.initialBallZoom.currentTime = currentTime;
          let percentComplete =
            (currentTime - window.appConfig.initialBallZoom.started) /
            window.appConfig.initialBallZoom.time;
          window.appConfig.initialBallZoom.percentComplete = percentComplete;
          console.log(
            "time left: " +
              (currentTime - window.appConfig.initialBallZoom.started)
          );
          console.log("time left %: " + percentComplete);
          if (
            currentTime - window.appConfig.initialBallZoom.started >
            window.appConfig.initialBallZoom.time
          ) {
            window.appConfig.initialBallZoom.ended = new Date().getTime();
            console.log(appConfig.initialBallZoom);
          }
        }

        const sphere = scene.children.find((obj) => obj.gameName === "SPHERE0");

        if (
          window.appConfig.start === false ||
          window.appConfig.pause === true
        ) {
          if (window.appConfig.start === false) {
            sphere.position.set(0, 10, 0);
          }
          scene.children
            .find((obj) => obj.gameName === "SPHERE0")
            .setLinearVelocity(new THREE.Vector3(0, 0, 0));
        } else {
          if (
            window.appConfig.touchStart === true &&
            window.appConfig.touchEnd === false
          ) {
            console.log("ACTIVE!!!");
            const scaleV = 0.5;
            scene.children
              .find((obj) => obj.gameName === "SPHERE0")
              .setLinearVelocity(
                new THREE.Vector3(
                  window.appConfig.diffX * scaleV,
                  window.appConfig.diffY * -scaleV,
                  0
                )
              );
          }
        }

        const spherePosition = scene.children.find(
          (obj) => obj.gameName === "SPHERE0"
        ).position;
        scene.children
          .find((obj) => obj.gameName === "POINTLIGHT0")
          .position.set(
            spherePosition.x,
            spherePosition.y + 1,
            spherePosition.z
          );

        const stageFloor = scene.children.find(
          (obj) => obj.name === "stageFloor"
        );
        const compareVector = new THREE.Vector3();
        const distanceSphereToStageFloor = compareVector
          .subVectors(
            new THREE.Vector3().setFromMatrixPosition(sphere.matrixWorld),
            new THREE.Vector3().setFromMatrixPosition(stageFloor.matrixWorld)
          )
          .length();
        const percentFinished = distanceSphereToStageFloor / 375;
        window.appConfig.percentFinished = percentFinished;
        if (new Date().getTime() % 10 < 3) {
          document.body.style.background =
            "linear-gradient(180deg, rgba(2,0,36,0) 0%, rgba(121,9,117,1) 0%, rgba(252,231,183,1) " +
            Math.round((1 - percentFinished) * 100) / 3 +
            "%, rgba(0,212,255,1)" +
            Math.round((1 - percentFinished) * 100) +
            "%)";
        }
        // if (distanceSphereToStageFloor > 50) {
        // camera.position.y = sphere.position.y + adjustCamera;
        camera.position.x = sphere.position.x;
        camera.position.y = sphere.position.y;
        // zoom into ball for reset
        // (window.appConfig.stageResultsBallZoom.percentComplete * 93.75)
        camera.position.z =
          10 +
          90 * window.appConfig.initialBallZoom.percentComplete -
          window.appConfig.stageResultsBallZoom.percentComplete * 90 -
          window.appConfig.stageReset.percentComplete * 5;

        if (window.appConfig.stageResultsBallZoom.userHasEnded) {
          scene.children
            .find((obj) => obj.gameName === "SPHERE0")
            .setLinearVelocity(new THREE.Vector3(0, 0, 0));
          scene.children
            .find((obj) => obj.gameName === "SPHERE0")
            .setAngularVelocity(new THREE.Vector3(0, 0, 0));
        }
        // }

        Object.keys(window.appConfig.featureTypes).forEach((key) => {
          window.appConfig.featureTypes[key].forEach(
            (feature, featureIndex) => {
              const newXRotation = feature.rotation.x + 0.01;
              const newYRotation = feature.rotation.y + 0.01;
              const newZRotation = feature.rotation.z + 0.01;
              feature.rotation.x = newXRotation;
              feature.rotation.y = newYRotation;
              feature.rotation.z = newZRotation;
              feature.__dirtyRotation = true;
            }
          );
        });
        let coinIndexToRemove = undefined;
        const potentiallyGrabbedCoin = window.appConfig.coins.find(
          (coin, coinIndex) => {
            coinIndexToRemove = coinIndex;
            return (
              Math.abs(coin.position.x - sphere.position.x) <
                coin.scale.z * 1.3 &&
              Math.abs(coin.position.y - sphere.position.y) < coin.scale.z * 1.3
            );
          }
        );

        if (potentiallyGrabbedCoin) {
          window.appConfig.score.coins += potentiallyGrabbedCoin.coinValue;
          scene.remove(potentiallyGrabbedCoin);
          window.appConfig.coins.splice(coinIndexToRemove, 1);
          potentiallyGrabbedCoin.geometry.dispose();
          potentiallyGrabbedCoin.material.dispose();
          document.querySelector("#score").innerText =
            window.appConfig.score.coins;
        }
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        render_stats.update();
        // toggleCurtain()
      };

      const start = () => {
        window.appConfig.start = true;
        document.querySelector("#start-button").classList.add("hide");
        document.querySelector("#pause-button").disabled = false;
        window.appConfig.initialBallZoom.userHasClickedStart = true;
        window.appConfig.timer.start();
        document.querySelector("#pause-button").disabled = false;
      };

      const pause = () => {
        window.appConfig.pause
          ? backgroundMusic0.play()
          : backgroundMusic0.pause();
        window.appConfig.pause = !window.appConfig.pause;
        if (window.appConfig.pause) {
          window.appConfig.timer.pause();
        } else {
          window.appConfig.timer.start();
        }
      };

      const reset = () => {
        window.appConfig.stageReset.userHasEndedReport = true;
        document.querySelector("#curtain").classList.remove("opacity-0");
        document.querySelector("#report").classList.add("hide");
        setTimeout(() => {
          console.log("fired");
          document.querySelector("#curtain").classList.add("opacity-0");
        }, 2000);
        // debugger
        // document.querySelector('#curtain').style.opacity = 1
        // window.appConfig.initialBallZoom.userHasClickedStart = true
        window.appConfig.timer.reset();
        window.appConfig.timer.pause();
      };

      window.onload = initScene;
    </script>
    <style>
      #start-button {
        position: fixed;
        left: 40%;
        top: 50%;
        padding: 10px 30px;
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
      }
      #pause-button {
        position: fixed;
        left: 3%;
        bottom: 3%;
        padding: 10px 30px;
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
      }
      .hide {
        display: none;
        visibility: hidden;
      }
      #timer {
        padding: 10px 30px;
        height: 100px;
        width: 200px;
        position: absolute;
        top: 3%;
        right: 3%;
      }

      #score {
        padding: 10px 30px;
        height: 100px;
        width: 200px;
        position: absolute;
        top: 6%;
        right: 3%;
      }
      #report {
        position: fixed;
        left: 40%;
        top: 50%;
        padding: 10px 30px;
        /* border: 3px solid black; */
        border: 0;
        border-radius: 5px;
        opacity: 0.75;
      }

      #curtain {
        transition: all 2000ms;
        pointer-events: none;
        background-color: white;
        z-index: 1;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 1;
      }

      .opacity-0 {
        opacity: 0 !important;
      }

      .opacity-1 {
        opacity: 1 !important;
      }
    </style>
  </head>

  <body>
    <div id="viewport"></div>
    <div id="timer"></div>
    <div id="score"></div>
    <div id="report" class="hide">
      <div id="time"></div>
      <div id="coins"></div>
      <button id="reset-button" onClick="reset()">Reset</button>
    </div>
    <button id="start-button" onClick="start()">Start</button>
    <button id="pause-button" disabled onClick="pause()">Pause</button>
    <div id="curtain"></div>
  </body>
</html>
