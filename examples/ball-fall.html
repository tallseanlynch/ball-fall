<!DOCTYPE html>

<html>

<head>
  <title>Ball Fall</title>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
    }

    html {
      touch-action: none;
    }
  </style>
  <link rel="stylesheet" href="./ballsinki.css">
  <script type="text/javascript" src="js/ammo.js"></script>
  <script type="text/javascript" src="js/three-121.js"></script>
  <script type="text/javascript" src="js/stats.js"></script>
  <script type="text/javascript" src="js/physi.js"></script>
  <script type="text/javascript" src="js/physijs_worker.js"></script>
  <!-- <script type="text/javascript" src="js/THREEOrbitControls.js"></script> -->
  <script type="text/javascript" src="js/easytimer.js"></script>
  <script type="text/javascript" src="js/howler.min.js"></script>
  <!-- <script src="https://unpkg.com/three@0.112.0/examples/js/loaders/GLTFLoader.js"></script> -->
  <script type="text/javascript" src="./features.js"></script>
  <script type="text/javascript" src="./event-handlers.js"></script>
  <script type="text/javascript" src="./debug.js"></script>
  <script type="text/javascript">
    "use strict";

    window.appConfig = {
      touchStart: false,
      touchEnd: false,
      currentX: 0,
      currentY: 0,
      prevX: 0,
      prevY: 0,
      diffX: 0,
      diffY: 0,
      start: false,
      pause: false,
      results: {},
      pause: false,
      itemAmounts: {
        crystalCross: 0,
        crystalLine: 0,
        crystalCircle: 0,
        bumperGroup: 0,
        prize: 0
      },
      currentStage: 'STAGE1',
      stagesArray: ['STAGE0', 'STAGE1'],
      currentStageIndex: 1
    };

    const backgroundMusics = [];
    const howlSounds = [];
    window.appConfig.howlSounds = howlSounds;
    window.appConfig.backgroundMusics = backgroundMusics;
    const loadSound = (options) => {
      const { src, type } = options;
      const sound = new Howl({
        src: [src],
        autoPlay: type === "backgroundMusic" ? true : false,
        loop: type === "backgroundMusic" ? true : false,
        volume: type === "backgroundMusic" ? 0.1 : 1,
      }).once("load", () => {
        if (type === "backgroundMusic") {
          backgroundMusics.push(sound);
          sound.play();
        } else {
          howlSounds.push(sound);
        }
      });
      return sound;
    };
    const backgroundMusic0 = loadSound({
      src: "sounds/BALL FALL jingle flat 1.mp3",
      type: "backgroundMusic",
    })
      .on("playerror", (id, e) => {
        console.log("playerror callback");
        console.dir(id);
        console.dir(e);
      })
      .on("fade", (e) => {
        console.log("fade callback");
        console.dir(e);
        console.dir(this);
      });
    const howlSound0 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a1.mp3",
      type: "howlSound",
    });
    const howlSound1 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a2.mp3",
      type: "howlSound",
    });
    const howlSound2 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a3.mp3",
      type: "howlSound",
    });
    const howlSound3 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a4.mp3",
      type: "howlSound",
    });
    const howlSound4 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a5.mp3",
      type: "howlSound",
    });
    const howlSound5 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a6.mp3",
      type: "howlSound",
    });
    const howlSound6 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a7.mp3",
      type: "howlSound",
    });
    const howlSound7 = loadSound({
      src: "sounds/Sound FX/BALL FALL fx a8.mp3",
      type: "howlSound",
    });

    Physijs.scripts.worker = "js/physijs_worker.js";
    Physijs.scripts.ammo = "ammo.js";

    const basicColors = [
      new THREE.Color(0xfff1e3),
      new THREE.Color(0xffd5c9),
      new THREE.Color(0xffa6bb),
      new THREE.Color(0xff757f),
      new THREE.Color(0x159294),
    ];

    let adjustCamera = 20;

    const getRandomColor = () => {
      return basicColors[Math.floor(Math.random() * basicColors.length)];
    };

    // LFO
    const lfoPositive = (t = 1000) => {
      let lfoValue = (0.5 + 0.5 * Math.cos(Date.now() / t)) * 1;
      return lfoValue;
    };

    const lfo = (t = 1000) => {
      return (0.5 - lfoPositive(t)) * 2;
    };
    const lfoPositiveStraight = (t = 1000) => {
      let lfoValue = (0.5 + 0.5 * Math.cos(Date.now() / t)) * 1;
      return lfoValue;
    };

    var initScene,
      render,
      _boxes = [],
      spawnBox,
      loader,
      renderer,
      render_stats,
      physics_stats,
      scene,
      ground_material,
      ground,
      light,
      camera,
      orbitControls;

    initScene = function () {
      window.appConfig.soundsBackDestination = "";
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      renderer.shadowMap.enabled = true;
      renderer.shadowMapSoft = true;
      document.getElementById("viewport").appendChild(renderer.domElement);

      render_stats = new Stats();
      render_stats.domElement.style.position = "absolute";
      render_stats.domElement.style.top = "0px";
      render_stats.domElement.style.zIndex = 100;
      document
        .getElementById("viewport")
        .appendChild(render_stats.domElement);

      physics_stats = new Stats();
      physics_stats.domElement.style.position = "absolute";
      physics_stats.domElement.style.top = "50px";
      physics_stats.domElement.style.zIndex = 100;
      document
        .getElementById("viewport")
        .appendChild(physics_stats.domElement);

      scene = new Physijs.Scene();

      scene.setGravity(new THREE.Vector3(0, -10, 0));

      scene.addEventListener("update", function () {
        scene.simulate(undefined, 1);
        physics_stats.update();
      });

      const skyColor = getRandomColor();
      const groundColor = getRandomColor();
      const hemisphereLight = new THREE.HemisphereLight(
        skyColor,
        groundColor,
        0.75
      );
      scene.add(hemisphereLight);

      camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        1000
      );

      adjustCamera = 20;
      camera.position.set(0, 10, 10);
      camera.lookAt(new THREE.Vector3(0, 10, 0));
      scene.add(camera);

      // Light
      light = new THREE.SpotLight(0xffffff);
      light.position.set(20, 80, 15);
      light.target.position.copy(scene.position);
      light.castShadow = true;
      light.shadowCameraLeft = -60;
      light.shadowCameraTop = -60;
      light.shadowCameraRight = 60;
      light.shadowCameraBottom = 60;
      light.shadowCameraNear = 20;
      light.shadowCameraFar = 200;
      light.shadowBias = -0.0001;
      light.shadowMapWidth = light.shadowMapHeight = 2048;
      light.shadowDarkness = 0.7;
      scene.add(light);

      const pointLight0 = new THREE.PointLight(getRandomColor(), 1);
      pointLight0.gameName = "POINTLIGHT0";
      pointLight0.power = 25;
      pointLight0.decay = 1;
      pointLight0.distance = 25;
      scene.add(pointLight0);

      // Orbit Controls
      // orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
      // orbitControls.enabled = false;

      //resize event handler
      function onWindowResize(event) {

        console.log('ran window resize', event)
        setFontSizes()
        centerElement({ id: "start-button", offsetTop: 0, offsetLeft: 0 });
        centerElement({ id: "level-select", offsetTop: 0, offsetLeft: 0 });
        centerElement({ id: "report", offsetTop: 0, offsetLeft: 0 });
        centerElement({ id: "pause-menu", offsetTop: 0, offsetLeft: 0 });
        centerElement({ id: "title", offsetTop: "-25%", offsetLeft: 0 });
        centerElement({ id: "start-menu", offsetTop: "25%", offsetLeft: 0 });
        var tanFOV = Math.tan(((Math.PI / 180) * camera.fov) / 2);
        var windowHeight = window.innerHeight;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.fov =
          (360 / Math.PI) *
          Math.atan(tanFOV * (window.innerHeight / windowHeight));

        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);
      }
      onWindowResize();
      window.addEventListener("resize", onWindowResize, false);

      loader = new THREE.TextureLoader();

      let level = 25;
      window.appConfig.level = level;
      let score = {
        coins: 0,
      };
      window.appConfig.score = score;

      const coins = [];
      window.appConfig.coins = coins;

      const createBeam = (config) => {
        const beam0 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(10 * config.s, 2, 2),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: config.color ? config.color : 0xffffff,
            }),
            0.6, // medium friction
            0.1 // low restitution
          ),
          0 // mass
        );
        const beam0cap0 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(1.45, 2, 1.45),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: config.color ? config.color : 0xffffff,
            }),
            0.6, // medium friction
            0.1 // low restitution
          ),
          0 // mass
        );
        const beam0cap1 = new Physijs.BoxMesh(
          new THREE.BoxGeometry(1.45, 2, 1.45),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: config.color ? config.color : 0xffffff,
            }),
            0.6, // medium friction
            0.1 // low restitution
          ),
          0 // mass
        );
        beam0cap0.rotation.y = 0.25 * Math.PI;
        beam0cap0.position.x = -5 * config.s;
        beam0.add(beam0cap0);
        beam0cap1.rotation.y = 0.25 * Math.PI;
        beam0cap1.position.x = 5 * config.s;
        beam0.add(beam0cap1);
        beam0.position.set(config.p[0], config.p[1], config.p[2]);
        beam0.rotation.set(config.r[0], config.r[1], config.r[2]);
        return beam0;
      };

      const crystal = (size = 0, p = { x: 0, y: 0, z: 0 }) => {
        const tripleHex = 0x159294;
        const doubleHex = 0xffa6bb;
        const singleHex = 0xffd5c9;
        const tripleScale = 2;
        const doubleScale = 1.5;
        const singleScale = 1;
        const xScaleMod = 0.5;
        const yScaleMod = 1;
        const zScaleMod = 0.5;

        const crystalMaterialOptions = {
          color: 0x000000,
          specular: 0x050505,
          shininess: 100
        };

        const coin = new THREE.Mesh();
        const crystalTop = new THREE.Mesh(
          new THREE.CylinderGeometry(0, 1, 0.5, 6),
          new THREE.MeshPhongMaterial(crystalMaterialOptions)
        );
        crystalTop.translateY(0.75);
        const crystalMiddle = new THREE.Mesh(
          new THREE.CylinderGeometry(1, 1, 1, 6),
          new THREE.MeshPhongMaterial(crystalMaterialOptions)
        );

        const crystalBottom = new THREE.Mesh(
          new THREE.CylinderGeometry(1, 0, 0.5, 6),
          new THREE.MeshPhongMaterial(crystalMaterialOptions)
        );
        crystalBottom.translateY(-0.75);
        coin.add(crystalTop);
        coin.add(crystalMiddle);
        coin.add(crystalBottom);
        coin.position.set(p.x, p.y, 0);
        coin.featureType = "COIN";
        if (size === 0) {
          coin.scale.set(
            singleScale * xScaleMod,
            singleScale * yScaleMod,
            singleScale * zScaleMod
          );
          coin.coinType = "single";
          coin.coinValue = 1;
          coin.coinHeight =
            coin.children.forEach((child) => {
              child.material.color.setHex(singleHex);
            });
        }
        if (size === 1) {
          coin.scale.set(
            doubleScale * xScaleMod,
            doubleScale * yScaleMod,
            doubleScale * zScaleMod
          );
          coin.coinType = "double";
          coin.coinValue = 2;
          coin.children.forEach((child) => {
            child.material.color.setHex(doubleHex);
          });
        }

        if (size === 2) {
          coin.scale.set(
            tripleScale * xScaleMod,
            tripleScale * yScaleMod,
            tripleScale * zScaleMod
          );
          coin.coinType = "triple";
          coin.coinValue = 3;
          coin.children.forEach((child) => {
            child.material.color.setHex(tripleHex);
          });
        }
        coins.push(coin);
        return coin;
      };

      const createCrystalCross = (name = "NO_NAME", s, t = { x: 0, y: 0 }, size = 0) => {
        const crystalCross = new THREE.Group()
        crystalCross.debugTypeIndex = window.appConfig.itemAmounts.crystalCross
        crystalCross.debugType = 'CRYSTALCROSS'
        crystalCross.debugName = 'CRYSTALCROSS' + window.appConfig.itemAmounts.crystalCross
        crystalCross.name = name + '_' + crystalCross.debugName

        crystalCross.add(crystal(size, { x: 0 * s + t.x, y: 1 * s + t.y, z: 0 }));
        crystalCross.add(crystal(size, { x: 0 * s + t.x, y: -1 * s + t.y, z: 0 }));
        crystalCross.add(crystal(size, { x: -1 * s + t.x, y: 0 * s + t.y, z: 0 }));
        crystalCross.add(crystal(size, { x: 1 * s + t.x, y: 0 * s + t.y, z: 0 }));
        scene.add(crystalCross)
        window.appConfig.itemAmounts.crystalCross++
      };

      const createCrystalCircle = (
        name = 'NO_NAME',
        s,
        t = { x: 0, y: 0 },
        size = 0,
        n
      ) => {
        const crystalCircle = new THREE.Group()
        crystalCircle.debugTypeIndex = window.appConfig.itemAmounts.crystalCircle
        crystalCircle.debugType = 'CRYSTALCIRCLE'
        crystalCircle.debugName = 'CRYSTALCIRCLE' + window.appConfig.itemAmounts.crystalCircle
        crystalCircle.name = name + '_' + crystalCircle.debugName
        var ellipse = new THREE.EllipseCurve(0, 0, s, s, 0, 2.0 * Math.PI, false);
        var ellipsePath = new THREE.CurvePath();
        ellipsePath.add(ellipse);
        var ellipseGeometry = ellipsePath.createPointsGeometry(4);
        console.log(ellipseGeometry)
        // debugger
        let i = 0;
        for (i; i < ellipseGeometry.vertices.length; i++) {
          crystalCircle.add(crystal(size, { x: ellipseGeometry.vertices[i].x * s + t.x, y: ellipseGeometry.vertices[i].y * s + t.y, z: 0 }));
        }
        scene.add(crystalCircle)
        window.appConfig.itemAmounts.crystalCircle++
      };


      const createCrystalLine = (
        name = 'NO_NAME',
        s,
        t = { x: 0, y: 0 },
        size = 0,
        n,
        dir = "x"
      ) => {
        const crystalLine = new THREE.Group()
        crystalLine.debugTypeIndex = window.appConfig.itemAmounts.crystalLine
        crystalLine.debugType = 'CRYSTALLINE'
        crystalLine.debugName = 'CRYSTALLINE' + window.appConfig.itemAmounts.crystalLine
        crystalLine.name = name + '_' + crystalLine.debugName
        let i = 0;
        for (i; i < n; i++) {
          if (dir === "x") {
            crystalLine.add(crystal(size, { x: i * s + t.x, y: t.y, z: 0 }));
          } else {
            crystalLine.add(crystal(size, { x: t.x, y: i * s + t.y, z: 0 }));
          }
        }
        scene.add(crystalLine)
        window.appConfig.itemAmounts.crystalLine++
      };

      const teardownStage = (stage) => {
        // remove all coins
        const uuidsToRemove = []
        scene.children.forEach(c => {
          if ((c.name.indexOf(stage) > -1) || (c.featureType && c.featureType === "COIN")) {
            uuidsToRemove.push(c.uuid)
          }
        })
        uuidsToRemove.forEach(uuid => {
          const foundIt = scene.children.find(c => c.uuid === uuid)
          scene.remove(foundIt)
        })
      }
      const registerStageObject = (stage, object) => {
        if (typeof object === 'object') {
          window.appConfig.stages[stage][object.name] = object
        } else if (typeof object === 'string') {
          const theObject = scene.children.find((obj) => obj.name === object)
          window.appConfig.stages[stage][theObject.name] = theObject
        }

      }

      // start stage 0
      window.appConfig.stages = {
        components: {
          createCrystalLine: createCrystalLine,
          createCrystalCircle: createCrystalCircle,
          createCrystalCross: createCrystalCross,
          createStage0MainBeamStructure: (
            scale,
            scaleAdj = 0,
            name,
            p = { x: 0, y: 0 }
          ) => {
            const mainStructure = new Physijs.BoxMesh(
              new THREE.BoxGeometry(0.01, 0.01, 0.01),
              new Physijs.createMaterial(
                new THREE.MeshPhongMaterial({ transparent: true, opacity: 0 }),
                0.6,
                0.3
              ),
              0
            );
            mainStructure.position.set(0 + p.x, 0 + p.y, 1.5);
            mainStructure.add(
              createBeam({
                p: [0 * scale, -8 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [-8 * scale, 0 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [8 * scale, 0 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [0 * scale, 8 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.name = name;
            mainStructure.__dirtyPosition = true;
            mainStructure.featureType = "BEAM"
            return mainStructure;
          },
          createStage1MinorBeamStructure: (
            scale,
            scaleAdj = 5,
            name,
            p = { x: 0, y: 0 }
          ) => {
            const minorBeamStructure = new Physijs.BoxMesh(
              new THREE.BoxGeometry(0.01, 0.01, 0.01),
              new Physijs.createMaterial(
                new THREE.MeshPhongMaterial({ transparent: true, opacity: 0 }),
                0.6,
                0.3
              ),
              0
            );
            minorBeamStructure.position.set(0 + p.x, 0 + p.y, 1.5);

            minorBeamStructure.add(
              createBeam({
                p: [20 * scale, 0 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );

            minorBeamStructure.add(
              createBeam({
                p: [-20 * scale, 0 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );

            minorBeamStructure.add(
              createBeam({
                p: [0 * scale, -20 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );

            minorBeamStructure.add(
              createBeam({
                p: [0 * scale, 20 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );

            minorBeamStructure.name = name;
            minorBeamStructure.__dirtyPosition = true;
            minorBeamStructure.featureType = "BEAM"
            return minorBeamStructure;
          },
          createStage1MainBeamStructure: (
            scale,
            scaleAdj = 5,
            name,
            p = { x: 0, y: 0 }
          ) => {
            const mainStructure = new Physijs.BoxMesh(
              new THREE.BoxGeometry(0.01, 0.01, 0.01),
              new Physijs.createMaterial(
                new THREE.MeshPhongMaterial({ transparent: true, opacity: 0 }),
                0.6,
                0.3
              ),
              0
            );
            mainStructure.position.set(0 + p.x, 0 + p.y, 1.5);
            mainStructure.add(
              createBeam({
                p: [-2 * scale, 4.75 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [2 * scale, 4.75 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [-2 * scale, -9.75 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [2 * scale, -9.75 * scale, -1],
                r: [0, 0, 0.5 * Math.PI],
                s: (1 + scaleAdj) * scale,
              })
            );

            mainStructure.add(
              createBeam({
                p: [7.5 * scale, -1 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [7.5 * scale, -4 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [-7.5 * scale, -1 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.add(
              createBeam({
                p: [-7.5 * scale, -4 * scale, -1],
                r: [0, 0, 0],
                s: (1 + scaleAdj) * scale,
              })
            );
            mainStructure.name = name;
            mainStructure.__dirtyPosition = true;
            mainStructure.featureType = "BEAM"
            return mainStructure;
          }
        },
        STAGE0: {
          data: {
            started: false,
            xAdj: -60,
            vAdj: -70,
            sAdj: 2,
            startingPosition: new THREE.Vector3(0, 0, 0)
          },
          defaultTransforms: [
            'STAGE0PRIZE0',
            'STAGE0PRIZE1',
            'STAGE0PRIZE2',
            'STAGE0PRIZE3',
            'STAGE0MAINSTRUCTURE',
            'STAGE0MINORSTRUCTURE',
            'STAGE0MINORSTRUCTURE1',
            'STAGE0MINORSTRUCTURE2',
            'STAGE0MINORSTRUCTURE3'
          ],
          transforms: {
            'STAGE0PRIZE0': { r: { x: .005, y: .005, z: .005 } },
            'STAGE0PRIZE1': { r: { x: .005, y: .005, z: .005 } },
            'STAGE0PRIZE2': { r: { x: .005, y: .005, z: .005 } },
            'STAGE0PRIZE3': { r: { x: .005, y: .005, z: .005 } },
            'STAGE0MAINSTRUCTURE': { r: { x: 0, y: 0, z: .001 } },
            'STAGE0MINORSTRUCTURE': { r: { x: 0, y: 0, z: -.001 } },
            'STAGE0MINORSTRUCTURE1': { r: { x: 0, y: 0, z: -.001 } },
            'STAGE0MINORSTRUCTURE2': { r: { x: 0, y: 0, z: -.001 } },
            'STAGE0MINORSTRUCTURE3': { r: { x: 0, y: 0, z: -.001 } }
          },
          teardown: () => {
            teardownStage('STAGE0')
            window.appConfig.stages.STAGE0.data.started = false
          },
          init: () => {

            const createStage0MainBeamStructure = window.appConfig.stages.components.createStage0MainBeamStructure

            const stage0MainBeamStructure = createStage0MainBeamStructure(
              2,
              0,
              "STAGE0MAINSTRUCTURE"
            );
            scene.add(stage0MainBeamStructure);
            const stage0MainBeamStructure1 = createStage0MainBeamStructure(
              4,
              0,
              "STAGE0MAINSTRUCTURE1"
            );
            scene.add(stage0MainBeamStructure1);
            const stage0MainBeamStructure2 = createStage0MainBeamStructure(
              8,
              0.525,
              "STAGE0MAINSTRUCTURE2"
            );
            scene.add(stage0MainBeamStructure2);
            const stage0MinorBeamStructure = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE",
              { x: 45, y: 45 }
            );
            scene.add(stage0MinorBeamStructure);
            const stage0MinorBeamStructure1 = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE1",
              { x: 45, y: -45 }
            );
            scene.add(stage0MinorBeamStructure1);
            const stage0MinorBeamStructure2 = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE2",
              { x: -45, y: -45 }
            );
            scene.add(stage0MinorBeamStructure2);
            const stage0MinorBeamStructure3 = createStage0MainBeamStructure(
              1,
              -0.5,
              "STAGE0MINORSTRUCTURE3",
              { x: -45, y: 45 }
            );
            scene.add(stage0MinorBeamStructure3);

            const prize0Group = new THREE.Group();
            const prize0 = new THREE.Mesh(
              new THREE.BoxGeometry(0.75, 0.75, 0.75),
              new THREE.MeshPhongMaterial()
            );
            const prize0Top = new THREE.Mesh(
              new THREE.ConeGeometry(1, 1, 8),
              new THREE.MeshPhongMaterial()
            );
            const prize0Bottom = new THREE.Mesh(
              new THREE.ConeGeometry(1, -1, 8),
              new THREE.MeshPhongMaterial()
            )
            prize0Group.name = 'STAGE0PRIZE0'
            prize0Group.debugTypeIndex = window.appConfig.itemAmounts.prize
            prize0Group.debugType = 'PRIZE'
            prize0Group.debugName = 'PRIZE' + window.appConfig.itemAmounts.prize
            window.appConfig.itemAmounts.prize++

            prize0.name = 'PRIZE0'
            prize0Top.name = 'PRIZE0TOP'
            prize0Bottom.name = 'PRIZE0BOTTOM'


            prize0.rotation.set(.25 * Math.PI, .25 * Math.PI, 0)
            prize0Group.add(prize0)
            prize0Group.add(prize0Top)
            prize0Group.add(prize0Bottom)

            prize0Top.position.y += 1.5
            prize0Bottom.position.y += -1.5
            prize0Group.position.set(45, 45, 0)

            scene.add(prize0Group)
            const prize1Group = prize0Group.clone()
            prize1Group.position.set(45, -45, 0)
            const prize2Group = prize0Group.clone()
            prize2Group.position.set(-45, -45, 0)
            const prize3Group = prize0Group.clone()
            prize3Group.position.set(-45, 45, 0)
            prize1Group.name = 'STAGE0PRIZE1'
            prize2Group.name = 'STAGE0PRIZE2'
            prize3Group.name = 'STAGE0PRIZE3'
            scene.add(prize1Group)
            scene.add(prize2Group)
            scene.add(prize3Group)
            prize0Group.prizeValue = 10
            prize1Group.prizeValue = 10
            prize2Group.prizeValue = 20
            prize3Group.prizeValue = 10

            //add prizes to the coins array so that they can be collected in the same manner
            coins.push(prize0Group);
            coins.push(prize1Group);
            coins.push(prize2Group);
            coins.push(prize3Group);

            createCrystalCross('STAGE0', 5);
            createCrystalCross('STAGE0', 10);
            createCrystalCross('STAGE0', 5, { x: 20, y: 20 }, 1);
            createCrystalCross('STAGE0', 5, { x: -20, y: 20 }, 1);
            createCrystalCross('STAGE0', 5, { x: -20, y: -20 }, 1);
            createCrystalCross('STAGE0', 5, { x: 20, y: -20 }, 1);
            createCrystalCross('STAGE0', 3, { x: 55, y: 55 }, 0);
            createCrystalCross('STAGE0', 3, { x: 35, y: 55 }, 0);
            createCrystalCross('STAGE0', 3, { x: 35, y: 35 }, 0);
            createCrystalCross('STAGE0', 3, { x: 55, y: 35 }, 0);
            createCrystalCross('STAGE0', 3, { x: 55, y: -55 }, 0);
            createCrystalCross('STAGE0', 3, { x: 35, y: -55 }, 0);
            createCrystalCross('STAGE0', 3, { x: 35, y: -35 }, 0);
            createCrystalCross('STAGE0', 3, { x: 55, y: -35 }, 0);
            createCrystalCross('STAGE0', 3, { x: -55, y: -55 }, 0);
            createCrystalCross('STAGE0', 3, { x: -35, y: -55 }, 0);
            createCrystalCross('STAGE0', 3, { x: -35, y: -35 }, 0);
            createCrystalCross('STAGE0', 3, { x: -55, y: -35 }, 0);
            createCrystalCross('STAGE0', 3, { x: -55, y: 55 }, 0);
            createCrystalCross('STAGE0', 3, { x: -35, y: 55 }, 0);
            createCrystalCross('STAGE0', 3, { x: -35, y: 35 }, 0);
            createCrystalCross('STAGE0', 3, { x: -55, y: 35 }, 0);
            createCrystalLine('STAGE0', 10, { x: -47.5, y: -20 }, 2, 5, "y");
            createCrystalLine('STAGE0', 5, { x: 54.5, y: -22 }, 0, 10, "y");
            createCrystalLine('STAGE0', 5, { x: 40.5, y: -22.5 }, 0, 10, "y");
            createCrystalLine('STAGE0', 10, { x: 47.5, y: -20 }, 2, 5, "y");
            createCrystalLine('STAGE0', 5, { x: -54.5, y: -22 }, 0, 10, "y");
            createCrystalLine('STAGE0', 5, { x: -40.5, y: -22.5 }, 0, 10, "y");
            createCrystalLine('STAGE0', 10, { x: -20, y: -47.5 }, 2, 5, "x");
            createCrystalLine('STAGE0', 5, { x: -22.5, y: -40 }, 0, 10, "x");
            createCrystalLine('STAGE0', 5, { x: -22.5, y: -54.5 }, 0, 10, "x");
            createCrystalLine('STAGE0', 10, { x: -20, y: 47.5 }, 2, 5, "x");
            createCrystalLine('STAGE0', 5, { x: -22.5, y: 40 }, 0, 10, "x");
            createCrystalLine('STAGE0', 5, { x: -22.5, y: 54.5 }, 0, 10, "x");
            // end stage 0

            window.appConfig.stages.STAGE0.STAGE0PRIZE0 = scene.children.find((obj) => obj.name === "STAGE0PRIZE0")
            window.appConfig.stages.STAGE0.STAGE0PRIZE1 = scene.children.find((obj) => obj.name === "STAGE0PRIZE1")
            window.appConfig.stages.STAGE0.STAGE0PRIZE2 = scene.children.find((obj) => obj.name === "STAGE0PRIZE2")
            window.appConfig.stages.STAGE0.STAGE0PRIZE3 = scene.children.find((obj) => obj.name === "STAGE0PRIZE3")
            window.appConfig.stages.STAGE0.STAGE0MAINSTRUCTURE = scene.children.find((obj) => obj.name === "STAGE0MAINSTRUCTURE")
            window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE")
            window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE1 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE1")
            window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE2 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE2")
            window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE3 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE3")
            window.appConfig.stages.STAGE0.data.started = true
          }
        },
        STAGE1: {
          data: {
            started: false,
            xAdj: -60,
            vAdj: -70,
            sAdj: 2,
            startingPosition: new THREE.Vector3(0, 0, 0)
          },
          defaultTransforms: [
            'STAGE1MINORSTRUCTURE',
            'STAGE1MINORSTRUCTUREA',
            'STAGE1MINORSTRUCTUREB',
            'STAGE1MINORSTRUCTURE1',
            'STAGE1MINORSTRUCTURE1A',
            'STAGE1MINORSTRUCTURE1B',
            'STAGE1MINORSTRUCTURE2',
            'STAGE1MINORSTRUCTURE2A',
            'STAGE1MINORSTRUCTURE2B',
            'STAGE1MINORSTRUCTURE3',
            'STAGE1MINORSTRUCTURE3A',
            'STAGE1MINORSTRUCTURE3B',
            'STAGE1PRIZE0',
            'STAGE1PRIZE1',
            'STAGE1PRIZE2',
            'STAGE1PRIZE3'
          ],
          transforms: {
            'STAGE1PRIZE0': { r: { x: .005, y: .005, z: .005 } },
            'STAGE1PRIZE1': { r: { x: .005, y: .005, z: .005 } },
            'STAGE1PRIZE2': { r: { x: .005, y: .005, z: .005 } },
            'STAGE1PRIZE3': { r: { x: .005, y: .005, z: .005 } },
            'STAGE1MINORSTRUCTURE': { r: { x: 0, y: 0, z: -.01 } },
            'STAGE1MINORSTRUCTUREA': { r: { x: 0, y: 0, z: .0025 } },
            'STAGE1MINORSTRUCTUREB': { r: { x: 0, y: 0, z: .0025 } },
            'STAGE1MINORSTRUCTURE1': { r: { x: 0, y: 0, z: .01 } },
            'STAGE1MINORSTRUCTURE1A': { r: { x: 0, y: 0, z: -.0025 } },
            'STAGE1MINORSTRUCTURE1B': { r: { x: 0, y: 0, z: -.0025 } },
            'STAGE1MINORSTRUCTURE2': { r: { x: 0, y: 0, z: .01 } },
            'STAGE1MINORSTRUCTURE2A': { r: { x: 0, y: 0, z: -.0025 } },
            'STAGE1MINORSTRUCTURE2B': { r: { x: 0, y: 0, z: -.0025 } },
            'STAGE1MINORSTRUCTURE3': { r: { x: 0, y: 0, z: -.01 } },
            'STAGE1MINORSTRUCTURE3A': { r: { x: 0, y: 0, z: .0025 } },
            'STAGE1MINORSTRUCTURE3B': { r: { x: 0, y: 0, z: .0025 } },
          },
          teardown: () => {
            teardownStage('STAGE1')
            window.appConfig.stages.STAGE1.data.started = false
          },
          init: () => {

            const createStage1MainBeamStructure = window.appConfig.stages.components.createStage1MainBeamStructure
            const createStage1MinorBeamStructure = window.appConfig.stages.components.createStage1MinorBeamStructure

            const stage1MainBeamStructure = createStage1MainBeamStructure(
              4,
              0,
              "STAGE1MAINSTRUCTURE",
              { x: 0, y: 10 }
            );
            scene.add(stage1MainBeamStructure);

            const stage1MainBeamStructure1 = window.appConfig.stages.components.createStage0MainBeamStructure(
              12,
              0.56,
              "STAGE1MAINSTRUCTURE1"
            );
            scene.add(stage1MainBeamStructure1);

            const stage1MinorBeamStructure = createStage1MinorBeamStructure(
              .5,
              .5,
              "STAGE1MINORSTRUCTURE",
              { x: 50, y: 50 }
            );
            scene.add(stage1MinorBeamStructure);

            const stage1MinorBeamStructureA = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTUREA",
              { x: 50, y: 50 }
            );
            scene.add(stage1MinorBeamStructureA);

            const stage1MinorBeamStructureB = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTUREB",
              { x: 50, y: 50 }
            );
            stage1MinorBeamStructureB.rotation.z = .25 * Math.PI
            scene.add(stage1MinorBeamStructureB);



            const stage1MinorBeamStructure1 = createStage1MinorBeamStructure(
              .5,
              .5,
              "STAGE1MINORSTRUCTURE1",
              { x: -50, y: 50 }
            );
            scene.add(stage1MinorBeamStructure1);

            const stage1MinorBeamStructure1A = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTURE1A",
              { x: -50, y: 50 }
            );
            scene.add(stage1MinorBeamStructure1A);

            const stage1MinorBeamStructure1B = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTURE1B",
              { x: -50, y: 50 }
            );
            stage1MinorBeamStructure1B.rotation.z = -.25 * Math.PI
            scene.add(stage1MinorBeamStructure1B);


            const stage1MinorBeamStructure2 = createStage1MinorBeamStructure(
              .5,
              .5,
              "STAGE1MINORSTRUCTURE2",
              { x: 50, y: -50 }
            );
            scene.add(stage1MinorBeamStructure2);

            const stage1MinorBeamStructure2A = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTURE2A",
              { x: 50, y: -50 }
            );
            scene.add(stage1MinorBeamStructure2A);

            const stage1MinorBeamStructure2B = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTURE2B",
              { x: 50, y: -50 }
            );
            stage1MinorBeamStructure2B.rotation.z = -.25 * Math.PI
            scene.add(stage1MinorBeamStructure2B);


            const stage1MinorBeamStructure3 = createStage1MinorBeamStructure(
              .5,
              .5,
              "STAGE1MINORSTRUCTURE3",
              { x: -50, y: -50 }
            );
            scene.add(stage1MinorBeamStructure3);

            const stage1MinorBeamStructure3A = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTURE3A",
              { x: -50, y: -50 }
            );
            scene.add(stage1MinorBeamStructure3A);

            const stage1MinorBeamStructure3B = createStage1MinorBeamStructure(
              1.5,
              -.5,
              "STAGE1MINORSTRUCTURE3B",
              { x: -50, y: -50 }
            );
            stage1MinorBeamStructure3B.rotation.z = .25 * Math.PI
            scene.add(stage1MinorBeamStructure3B);

            const prize0Group = new THREE.Group();
            const prize0 = new THREE.Mesh(
              new THREE.BoxGeometry(0.75, 0.75, 0.75),
              new THREE.MeshPhongMaterial()
            );
            const prize0Top = new THREE.Mesh(
              new THREE.ConeGeometry(1, 1, 8),
              new THREE.MeshPhongMaterial()
            );
            const prize0Bottom = new THREE.Mesh(
              new THREE.ConeGeometry(1, -1, 8),
              new THREE.MeshPhongMaterial()
            )
            prize0Group.name = 'STAGE1PRIZE0'
            prize0Group.debugTypeIndex = window.appConfig.itemAmounts.prize
            prize0Group.debugType = 'PRIZE'
            prize0Group.debugName = 'PRIZE' + window.appConfig.itemAmounts.prize
            window.appConfig.itemAmounts.prize++

            prize0.name = 'PRIZE0'
            prize0Top.name = 'PRIZE0TOP'
            prize0Bottom.name = 'PRIZE0BOTTOM'


            prize0.rotation.set(.25 * Math.PI, .25 * Math.PI, 0)
            prize0Group.add(prize0)
            prize0Group.add(prize0Top)
            prize0Group.add(prize0Bottom)

            prize0Top.position.y += 1.5
            prize0Bottom.position.y += -1.5
            prize0Group.position.set(50, 50, 0)

            scene.add(prize0Group)
            const prize1Group = prize0Group.clone()
            prize1Group.position.set(50, -50, 0)
            const prize2Group = prize0Group.clone()
            prize2Group.position.set(-50, -50, 0)
            const prize3Group = prize0Group.clone()
            prize3Group.position.set(-50, 50, 0)
            prize1Group.name = 'STAGE1PRIZE1'
            prize2Group.name = 'STAGE1PRIZE2'
            prize3Group.name = 'STAGE1PRIZE3'
            scene.add(prize1Group)
            scene.add(prize2Group)
            scene.add(prize3Group)
            prize0Group.prizeValue = 10
            prize1Group.prizeValue = 10
            prize2Group.prizeValue = 20
            prize3Group.prizeValue = 10

            //add prizes to the coins array so that they can be collected in the same manner
            coins.push(prize0Group);
            coins.push(prize1Group);
            coins.push(prize2Group);
            coins.push(prize3Group);

            createCrystalCross('STAGE1', 5, { x: 20, y: 19 }, 1);
            createCrystalCross('STAGE1', 5, { x: -20, y: 19 }, 1);
            createCrystalCross('STAGE1', 5, { x: -20, y: -19 }, 1);
            createCrystalCross('STAGE1', 5, { x: 20, y: -19 }, 1);

            createCrystalCross('STAGE1', 5, { x: 85, y: 84 }, 2);
            createCrystalCross('STAGE1', 5, { x: 85, y: -84 }, 2);
            createCrystalCross('STAGE1', 5, { x: -85, y: -84 }, 2);
            createCrystalCross('STAGE1', 5, { x: -85, y: 84 }, 2);

            createCrystalLine('STAGE1', 5, { x: 89.5, y: -35 }, 0, 15, "y");
            createCrystalLine('STAGE1', 5, { x: 75.5, y: -10 }, 0, 5, "y");
            createCrystalLine('STAGE1', 10, { x: 82.5, y: -20 }, 2, 5, "y");
            createCrystalLine('STAGE1', 4, { x: 58, y: 0 }, 1, 4, "x");

            createCrystalLine('STAGE1', 5, { x: -89.5, y: -35 }, 0, 15, "y");
            createCrystalLine('STAGE1', 5, { x: -75.5, y: -10 }, 0, 5, "y");
            createCrystalLine('STAGE1', 10, { x: -82.5, y: -20 }, 2, 5, "y");
            createCrystalLine('STAGE1', 4, { x: -70, y: 0 }, 1, 4, "x");

            createCrystalLine('STAGE1', 5, { x: -35, y: -89.5 }, 0, 15, "x");
            createCrystalLine('STAGE1', 5, { x: -10, y: -75.5 }, 0, 5, "x");
            createCrystalLine('STAGE1', 10, { x: -20, y: -82.5 }, 2, 5, "x");
            createCrystalLine('STAGE1', 4, { x: 0, y: -70 }, 1, 4, "y");

            createCrystalLine('STAGE1', 5, { x: -35, y: 89.5 }, 0, 15, "x");
            createCrystalLine('STAGE1', 5, { x: -10, y: 75.5 }, 0, 5, "x");
            createCrystalLine('STAGE1', 10, { x: -20, y: 82.5 }, 2, 5, "x");
            createCrystalLine('STAGE1', 4, { x: 0, y: 57.5 }, 1, 4, "y");

            createCrystalLine('STAGE1', 5, { x: 0, y: 15 }, 0, 8, "y");

            createCrystalLine('STAGE1', 5, { x: 0, y: -50 }, 0, 8, "y");
            
            createCrystalLine('STAGE1', 5, { x: 15, y: 0 }, 0, 8, "x");
            createCrystalLine('STAGE1', 5, { x: -50, y: 0 }, 0, 8, "x");

            createCrystalCircle('STAGE1', 4.5, {x: 50, y:50 }, 1, 5)
            createCrystalCircle('STAGE1', 4.5, {x: 50, y:-50 }, 1, 5)
            createCrystalCircle('STAGE1', 4.5, {x: -50, y:-50 }, 1, 5)
            createCrystalCircle('STAGE1', 4.5, {x: -50, y:50 }, 1, 5)

            window.appConfig.stages.STAGE1.STAGE1PRIZE0 = scene.children.find((obj) => obj.name === "STAGE1PRIZE0")
            window.appConfig.stages.STAGE1.STAGE1PRIZE1 = scene.children.find((obj) => obj.name === "STAGE1PRIZE1")
            window.appConfig.stages.STAGE1.STAGE1PRIZE2 = scene.children.find((obj) => obj.name === "STAGE1PRIZE2")
            window.appConfig.stages.STAGE1.STAGE1PRIZE3 = scene.children.find((obj) => obj.name === "STAGE1PRIZE3")
            window.appConfig.stages.STAGE1.STAGE1MAINSTRUCTURE = scene.children.find((obj) => obj.name === "STAGE1MAINSTRUCTURE")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTUREA = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTUREA")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTUREB = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTUREB")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE1 = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE1")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE1A = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE1A")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE1B = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE1B")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE2 = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE2")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE2A = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE2A")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE2B = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE2B")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE3 = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE3")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE3A = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE3A")
            window.appConfig.stages.STAGE1.STAGE1MINORSTRUCTURE3B = scene.children.find((obj) => obj.name === "STAGE1MINORSTRUCTURE3B")
            // window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE1 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE1")
            // window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE2 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE2")
            // window.appConfig.stages.STAGE0.STAGE0MINORSTRUCTURE3 = scene.children.find((obj) => obj.name === "STAGE0MINORSTRUCTURE3")
            window.appConfig.stages.STAGE1.data.started = true
          }
        }
      }

      // window.appConfig.stages.STAGE0.init()
      window.appConfig.stages[window.appConfig.currentStage].init()

      spawnBox();

      requestAnimationFrame(render);
      scene.simulate();
      const timer = new easytimer.Timer({ countdown: true, startValues: { seconds: 60 }, precision: "secondTenths" });
      window.appConfig.timer = timer
      timer.addEventListener("secondTenthsUpdated", function (e) {
        document.querySelector(
          "#timer"
        ).innerText = `${timer
          .getTimeValues()
          .toString(["minutes", "seconds", "secondTenths"])}`;
      });
      timer.addEventListener("targetAchieved", function (e) {
        startStageEnd()
      })
      document.querySelector("#curtain").classList.add("opacity-0");
    };

    spawnBox = (function () {
      var sphere_geometry = new THREE.SphereGeometry(1, 32, 32),
        collisionInc = 0,
        lastCollisions = ["", "", ""],
        handleCollision = function (
          collided_with,
          linearVelocity,
          angularVelocity
        ) {
          console.log("collision");
          console.log("collided_with", collided_with);
          if (appConfig.pause === false) {
            const suonousFeatureTypes = [
              "BEAM",
              "BOX",
              "ICOSAHEDRON",
              "TETRAHEDRON",
              "CONE",
              "DISC",
              "TORUS",
              "PLINKO",
              "COIN",
            ];

            const playHowlOnCollision = [
              function () {
                howlSound0.play();
              },
              function () {
                howlSound1.play();
              },
              function () {
                howlSound2.play();
              },
              function () {
                howlSound3.play();
              },
              function () {
                howlSound4.play();
              },
              function () {
                howlSound5.play();
              },
              function () {
                howlSound6.play();
              },
              function () {
                howlSound7.play();
              }
            ]
            if (suonousFeatureTypes.indexOf(collided_with.featureType) > -1) {

              const sphere = scene.children.find(obj => {
                if (obj.gameName === "SPHERE0" && obj.type === "Mesh") {
                  return obj
                }
              })
              const i = Math.floor(collisionInc % playHowlOnCollision.length)
              if (!(lastCollisions[0] === collided_with.uuid && lastCollisions[1] === collided_with.uuid && lastCollisions[2] === collided_with.uuid)) {
                playHowlOnCollision[i]()
                collisionInc++
                lastCollisions.push(collided_with.uuid)
              }
              if (lastCollisions.length > 3) {
                lastCollisions.shift()
              }
              console.log("AFTERPLAY");
            }
          }
        }

      let createSphere = function () {
        var sphere, material;

        material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            color: 0xffffff,
            // envMap: scene.background,
            // combine: THREE.MixOperation,
            reflectivity: 100,
            transparent: true,
            opacity: 0.95,
            specular: 0x050505,
            shininess: 200
          }),
          0.5, // medium friction
          1 // low restitution
        );
        sphere = new Physijs.SphereMesh(sphere_geometry, material);
        sphere.collisions = 0;
        // sphere.position.set(window.appConfig.stages[window.appConfig.currentStage].data.startingPosition);
        sphere.position.set(0, 0, 0);

        sphere.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );

        sphere.castShadow = true;
        sphere.addEventListener("collision", handleCollision);
        sphere.gameName = "SPHERE0";
        sphere.name = "SPHERE0";
        sphere.setCcdMotionThreshold(.5)
        sphere.setCcdSweptSphereRadius(1)
        scene.add(sphere);
        window.appConfig.sphere = sphere
      };
      return () => {
        createSphere();
        const setSpriteSpherical = (sprite) => {
          const spritePhi = (lfoPositive((sprite.phiT + sprite.phiMod * sprite.phiT)) + lfoPositive(100 * Math.random()) / 500) * (2 * Math.PI)
          const spriteTheta = (lfo((sprite.thetaT + sprite.thetaMod * sprite.thetaT)) + lfo(721 * Math.random()) / 1000) * (Math.PI)
          sprite.spherical.set(sprite.radius + lfoPositive(1111) * 10, spritePhi, spriteTheta)
        }
        // make sprites
        const sprites = []
        window.appConfig.sprites = sprites
        const createSprite = () => {
          const spriteGeometry = new THREE.SphereGeometry(.2, 16, 16)
          const spriteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: .5 })
          const thetaMod = Math.random()
          const phiMod = Math.random()
          const sprite0Mesh = new THREE.Mesh(spriteGeometry, spriteMaterial)
          scene.add(sprite0Mesh)
          let sprite0 = {
            mesh: sprite0Mesh,
            spherical: new THREE.Spherical(),
            radius: 1.5,
            thetaT: 1500,
            phiT: 2000,
            thetaMod: thetaMod,
            phiMod: phiMod
          }



          sprite0.activeCallback = () => {
            setSpriteSpherical(sprite0)
            const spriteVector3 = new THREE.Vector3()
            spriteVector3.setFromSpherical(sprite0.spherical)
            spriteVector3.x = spriteVector3.x + window.appConfig.sphere.position.x
            spriteVector3.y = spriteVector3.y + window.appConfig.sphere.position.y
            spriteVector3.z = spriteVector3.z + window.appConfig.sphere.position.z
            sprite0.mesh.position.x = spriteVector3.x
            sprite0.mesh.position.y = spriteVector3.y
            sprite0.mesh.position.z = spriteVector3.z
            sprite0.mesh.material.opacity = .5 + (lfoPositive(1000) + lfoPositive(77) / 2)
            sprite0.mesh.name = "sprite"
          }
          sprites.push(sprite0)

        }
        createSprite()
        createSprite()
        createSprite()



        const sidesColor = getRandomColor();

        const glassMesh0 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(1000, 1000, 1),
            /*material*/ new THREE.MeshBasicMaterial({
          color: getRandomColor(),
          opacity: 0,
          transparent: true,
          wifeframe: true,
        }),
            /*mass*/ 0
        );
        glassMesh0.gameName = "FRONTGLASS";
        glassMesh0.name = "glassMesh0";

        const glassMesh1 = new Physijs.BoxMesh(
            /*geometry*/ new THREE.BoxGeometry(1000, 1000, 1),
            /*material*/ new THREE.MeshBasicMaterial({
          color: getRandomColor(),
          opacity: 0.0,
          transparent: true,
          wifeframe: true,
        }),
            /*mass*/ 0
        );
        glassMesh1.gameName = "BACKGLASS";
        glassMesh1.name = "glassMesh1";

        glassMesh0.position.z = 1.5;
        glassMesh1.position.z = -1.5;
        glassMesh0.position.y = -137.5;
        glassMesh1.position.y = -140;
        glassMesh0.__dirtyPosition = true;
        glassMesh0.__dirtyRotation = true;
        glassMesh1.__dirtyPosition = true;
        glassMesh1.__dirtyRotation = true;

        scene.add(glassMesh0);
        scene.add(glassMesh1);

      };
    })();

    let appStartTime = new Date().getTime();
    let initialBallZoomTime = 0;

    window.appConfig.activeTransforms = []

    let currentTime = new Date().getTime();

    const timers = {
      initialBallZoom: () => {
        return {
          started: 0,
          ended: 0,
          z: scene.children.find((obj) => obj.gameName === "SPHERE0")
            .position.z,
          percentComplete: 0,
          time: 2000,
          timeLeft: 1000,
          currentTime: 0,
          name: 'INITIALBALLZOOM',
          id: Math.round(Math.random() * 10000),
          activeCallback: (percentComplete) => {
            window.appConfig.timers.data.initialBallZoom.percentComplete = percentComplete
          }
        }
      },
      stageReset: (action) => {
        return {
          started: 0,
          ended: 0,
          z: scene.children.find((obj) => obj.gameName === "SPHERE0")
            .position.z,
          percentComplete: 0,
          time: 2000,
          timeLeft: 1000,
          currentTime: 0,
          name: 'STAGERESET',
          id: Math.round(Math.random() * 10000),
          activeCallback: (percentComplete) => {
            window.appConfig.timers.data.stageReset.percentComplete = percentComplete
          },
          completedCallback: (percentComplete) => {
            window.appConfig.stages[window.appConfig.currentStage].teardown()

            if(action && action.action === 'next') {
              window.appConfig.currentStageIndex++
              if(window.appConfig.currentStageIndex >= window.appConfig.stagesArray.length) {
                window.appConfig.currentStageIndex = 0
              }
              window.appConfig.currentStage = window.appConfig.stagesArray[window.appConfig.currentStageIndex]
            }

            window.appConfig.gameModeFunctions.start()
            document.querySelector("#curtain").classList.add("opacity-0");
            const restartBallPosition = window.appConfig.stages[window.appConfig.currentStage].data.startingPosition
            window.appConfig.positionBall(restartBallPosition)
            window.appConfig.positionCamera(restartBallPosition)
          }
        }
      },
      stageResultsBallZoom: () => {
        return {
          started: 0,
          ended: 0,
          z: scene.children.find((obj) => obj.gameName === "SPHERE0")
            .position.z,
          percentComplete: 0,
          time: 2000,
          timeLeft: 1000,
          currentTime: 0,
          name: 'STAGERESULTSBALLZOOM',
          id: Math.round(Math.random() * 10000),
          activeCallback: (percentComplete) => {
            window.appConfig.timers.data.stageResultsBallZoom.percentComplete = percentComplete
          }
        }
      },
      data: {
        initialBallZoom: {
          percentComplete: 0
        },
        stageReset: {
          percentComplete: 0
        },
        stageResultsBallZoom: {
          percentComplete: 0
        }
      },
      activeTimers: []
    }

    window.appConfig.timers = timers
    const appTimers = window.appConfig.timers
    render = function () {

      currentTime = new Date().getTime();

      if (!window.appConfig.stages[window.appConfig.currentStage].data.started) {
        window.appConfig.stages[window.appConfig.currentStage].init()
      } else {
        if (window.appConfig.pause === false) {
          window.appConfig.activeTransforms.length > 0 && window.appConfig.activeTransforms.forEach(t => {
            if (window.appConfig.stages[window.appConfig.currentStage].transforms[t].r && window.appConfig.stages[window.appConfig.currentStage][t]) {
              window.appConfig.stages[window.appConfig.currentStage][t].rotation.x += window.appConfig.stages[window.appConfig.currentStage].transforms[t].r.x
              window.appConfig.stages[window.appConfig.currentStage][t].rotation.y += window.appConfig.stages[window.appConfig.currentStage].transforms[t].r.y
              window.appConfig.stages[window.appConfig.currentStage][t].rotation.z += window.appConfig.stages[window.appConfig.currentStage].transforms[t].r.z
              window.appConfig.stages[window.appConfig.currentStage][t].__dirtyRotation = true
            }
            if (window.appConfig.stages[window.appConfig.currentStage].transforms[t].t && window.appConfig.stages[window.appConfig.currentStage][t]) {
              window.appConfig.stages[window.appConfig.currentStage][t].position.x += window.appConfig.stages[window.appConfig.currentStage].transforms[t].t.x
              window.appConfig.stages[window.appConfig.currentStage][t].position.y += window.appConfig.stages[window.appConfig.currentStage].transforms[t].t.y
              window.appConfig.stages[window.appConfig.currentStage][t].position.z += window.appConfig.stages[window.appConfig.currentStage].transforms[t].t.z
              window.appConfig.stages[window.appConfig.currentStage][t].__dirtyPosition = true
            }
            if (window.appConfig.stages[window.appConfig.currentStage].transforms[t].callback && window.appConfig.stages[window.appConfig.currentStage][t]) {
              callback(t, window.appConfig.stages[window.appConfig.currentStage].transforms[t])
            }
          })
        }
      }

      if (appTimers.activeTimers.length > 0) {
        let removeTimersArray = []
        appTimers.activeTimers.forEach((t, ti) => {
          if (appTimers.activeTimers[ti].started === 0) {
            appTimers.activeTimers[ti].started = currentTime
            appTimers.activeTimers[ti].currentTime = currentTime
            if (appTimers.activeTimers[ti].startedCallback) {
              appTimers.activeTimers[ti].startedCallback(appTimers.activeTimers[ti].percentComplete)
            }
          }
          if (appTimers.activeTimers[ti].started !== 0 && appTimers.activeTimers[ti].ended === 0) {
            appTimers.activeTimers[ti].currentTime = currentTime
            appTimers.activeTimers[ti].percentComplete = (currentTime - appTimers.activeTimers[ti].started) / appTimers.activeTimers[ti].time;
            appTimers.activeTimers[ti].timeLeft = (currentTime - appTimers.activeTimers[ti].started)
            console.log("time left: " + appTimers.activeTimers[ti].timeLeft);
            console.log("% complete: " + appTimers.activeTimers[ti].percentComplete);
            if (appTimers.activeTimers[ti].activeCallback) {
              appTimers.activeTimers[ti].activeCallback(appTimers.activeTimers[ti].percentComplete)
            }
            if (appTimers.activeTimers[ti].timeLeft > appTimers.activeTimers[ti].time) {
              // end the timer --> this will make the first check not fire the function since ended has a value
              appTimers.activeTimers[ti].ended = currentTime
              console.log('timer ended: ', appTimers.activeTimers[ti]);
              removeTimersArray.push(appTimers.activeTimers[ti].name)
              if (appTimers.activeTimers[ti].completedCallback) {
                appTimers.activeTimers[ti].completedCallback(appTimers.activeTimers[ti].percentComplete)
              }
            }
          }
        })
        if (removeTimersArray.length > 0) {
          removeTimersArray.forEach(rt => {
            appTimers.activeTimers.forEach((at, ati) => {
              if (at.name === rt) {
                appTimers.activeTimers.splice(ati, 1)
              }
            })
          })
        }
      }

      const sphere = scene.children.find((obj) => obj.gameName === "SPHERE0");
      const pointLight0 = scene.children
        .find((obj) => obj.gameName === "POINTLIGHT0")
      if (
        window.appConfig.start === false ||
        window.appConfig.pause === true
      ) {
        if (window.appConfig.start === false) {
          sphere.position.set(0, 10, 0);
        }
        sphere
          .setLinearVelocity(new THREE.Vector3(0, 0, 0));
      } else {
        if (
          window.appConfig.touchStart === true &&
          window.appConfig.touchEnd === false
        ) {
          console.log("ACTIVE!!!");
          const scaleV = 0.25;
          let newVelocity = new THREE.Vector3(
            window.appConfig.diffX * scaleV,
            window.appConfig.diffY * -scaleV,
            // Math.abs(window.appConfig.diffX * scaleV) < 25 ? window.appConfig.diffX * scaleV : 25,
            // Math.abs(window.appConfig.diffY * -scaleV) < 25 ? window.appConfig.diffY * -scaleV : -25,
            0
          )
          const speedClamp = 50
          const newVelocityLength = newVelocity.length()
          if (newVelocityLength > speedClamp) {
            //            debugger
            newVelocity = newVelocity.multiplyScalar(speedClamp / newVelocityLength)
          }
          console.log(newVelocity)
          sphere
            .setLinearVelocity(newVelocity)
        }
      }

      pointLight0.position.set(
        sphere.position.x,
        sphere.position.y + 1,
        sphere.position.z
      );

      const percentFinished = Math.abs(sphere.position.y) / 375;
      window.appConfig.percentFinished = percentFinished;
      if (currentTime % 10 < 3) {
        document.body.style.background =
          "linear-gradient(180deg, rgba(2,0,36,0) 0%, rgba(121,9,117,1) 0%, rgba(252,231,183,1) " +
          Math.round((1 - percentFinished) * 100) / 3 +
          "%, rgba(0,212,255,1)" +
          Math.round((1 - percentFinished) * 100) +
          "%)";
      }


      // camera positioning
      camera.position.x = sphere.position.x;
      camera.position.y = sphere.position.y;
      camera.position.z =
        10 +
        90 * window.appConfig.timers.data.initialBallZoom.percentComplete -
        window.appConfig.timers.data.stageResultsBallZoom.percentComplete * 90 -
        window.appConfig.timers.data.stageReset.percentComplete * 5;

      if (window.appConfig.userHasEnded) {
        sphere
          .setLinearVelocity(new THREE.Vector3(0, 0, 0));
        sphere
          .setAngularVelocity(new THREE.Vector3(0, 0, 0));
      }
      //handle sprites
      window.appConfig.sprites.forEach(sprite => {
        sprite.activeCallback()
      }
      )




      const sphereLinearVelocityLength = sphere.getLinearVelocity().length()
      const xCoinMod = 2 + sphereLinearVelocityLength * .03
      const yCoinMod = 3 + sphereLinearVelocityLength * .03

      let coinIndexToRemove = undefined;
      const potentiallyGrabbedCoin = window.appConfig.coins.find(
        (coin, coinIndex) => {
          coinIndexToRemove = coinIndex;
          if (
            Math.abs(coin.position.x - sphere.position.x) <
            coin.scale.x * xCoinMod &&
            Math.abs(coin.position.y - sphere.position.y) < coin.scale.x * yCoinMod) {
            return true
          } else return false;
        }
      );

      if (potentiallyGrabbedCoin) {
        console.log(potentiallyGrabbedCoin)
        const coinValue = potentiallyGrabbedCoin.coinValue
        const prizeValue = potentiallyGrabbedCoin.prizeValue
        if (coinValue > 0) {
          window.appConfig.score.coins += potentiallyGrabbedCoin.coinValue;
          potentiallyGrabbedCoin.visible = false
          window.appConfig.coins.splice(coinIndexToRemove, 1);
          document.querySelector("#score").innerText =
            window.appConfig.score.coins;
        } else if (prizeValue > 0) {
          window.appConfig.score.coins += potentiallyGrabbedCoin.prizeValue;
          window.appConfig.coins.splice(coinIndexToRemove, 1);
          document.querySelector("#score").innerText =
            window.appConfig.score.coins;
          startStageEnd()
        }
      }

      requestAnimationFrame(render);
      renderer.render(scene, camera);
      render_stats.update();
    };

    window.appConfig.positionBall = (p) => {
      const sphere = scene.children.find((obj) => obj.gameName === "SPHERE0")
      sphere.position.x = p.x
      sphere.position.y = p.y
      sphere.position.z = p.z
      sphere.__dirtyPosition = true
    }

    window.appConfig.positionCamera = (p) => {
      const cam = scene.children.find((obj) => obj.type === "PerspectiveCamera")
      cam.position.x = p.x
      cam.position.y = p.y
      cam.position.z = p.z
      cam.__dirtyPosition = true
    }

    const calculateStageScore = (seconds, coins) => {
      let normalizedSeconds = Math.floor(seconds)
      if (normalizedSeconds < 1) {
        normalizedSeconds = 1
      }
      let score = normalizedSeconds * coins
      return score
    }

    const startStageEnd = () => {
      //now start end of stage
      window.appConfig.userHasEnded = true
      window.appConfig.timers.activeTimers.push(window.appConfig.timers.stageResultsBallZoom())
      window.appConfig.timer.pause();
      window.appConfig.results[`stage${window.appConfig.level}`]
        ? (window.appConfig.results[
          `stage${window.appConfig.level}`
        ].finalTime = window.appConfig.timer
          .getTimeValues()
          .toString(["minutes", "seconds", "secondTenths"]))
        : (window.appConfig.results[
          `stage${window.appConfig.level}`
        ] = {
          finalTime: window.appConfig.timer
            .getTimeValues()
            .toString(["minutes", "seconds", "secondTenths"]),
        });
      //now performance report and start level transition
      console.dir(window.appConfig.results);
      const stageScore = calculateStageScore(window.appConfig.timer
        .getTimeValues().seconds, window.appConfig.score.coins)
      document.querySelector("#report-time").innerText =
        window.appConfig.results[
          `stage${window.appConfig.level}`
        ].finalTime;
      document.querySelector("#report-coins").innerText =
        window.appConfig.score.coins;
      document.querySelector("#report-score").innerText =
        stageScore;
      showHTMLElements(["report", "tinted-overlay"]);
      centerElement({ id: "report", offsetTop: 0, offsetLeft: 0 });
      document.querySelector("#pause-button").disabled = true;

    }

    const start = () => {
      window.appConfig.userHasEnded = false
      window.appConfig.start = true;
      window.appConfig.pause = false;
      if (!backgroundMusic0.playing()) (
        backgroundMusic0.play()
      )
      scene.setGravity(new THREE.Vector3(0, -10, 0));
      showHTMLElements(["pause-button", "game-scoreboard"]);
      // window.appConfig.initialBallZoom.userHasClickedStart = true;
      window.appConfig.timers.data.initialBallZoom.percentComplete = 0
      window.appConfig.timers.data.stageReset.percentComplete = 0
      window.appConfig.timers.data.stageResultsBallZoom.percentComplete = 0
      window.appConfig.timers.activeTimers.push(timers.initialBallZoom())
      window.appConfig.timer.start();
      document.querySelector("#pause-button").disabled = false;
      const theBall = scene.children.find(c => c.gameName === 'SPHERE0')
      theBall.position.set(window.appConfig.stages[window.appConfig.currentStage].data.startingPosition);
      window.appConfig.activeTransforms = window.appConfig.stages[window.appConfig.currentStage].defaultTransforms
      const sphere = scene.children.find(obj => {
        if (obj.gameName === "SPHERE0" && obj.type === "Mesh") {
          return obj
        }
      })
      sphere.setLinearVelocity(new THREE.Vector3(0, -10, 0))
    };

    const pause = () => {
      window.appConfig.pause
        ? backgroundMusic0.play()
        : backgroundMusic0.pause();
      window.appConfig.pause = !window.appConfig.pause;
      if (window.appConfig.pause) {
        window.appConfig.timer.pause();
        scene.setGravity(new THREE.Vector3(0, 0, 0));
        showPauseMenu();
      } else {
        window.appConfig.timer.start();
        scene.setGravity(new THREE.Vector3(0, -10, 0));
        showGameMode();
      }
    };

    const reset = (action) => {
      window.appConfig.timers.activeTimers.push(window.appConfig.timers.stageReset(action))
      window.appConfig.results = {}
      window.appConfig.score.coins = 0
      document.querySelector("#score").innerText = 0
      showHTMLElements([]);
      document.querySelector("#curtain").classList.remove("opacity-0");
      window.appConfig.timer.reset();
      window.appConfig.timer.pause();
      window.appConfig.activeTransforms = []
    };

    window.appConfig.gameModeFunctions = {
      start: start,
      reset: reset,
      pause: pause
    }
    const showLevelSelect = () => {
      showHTMLElements(["level-select", "tinted-overlay"]);
      centerElement({ id: "level-select", offsetTop: 0, offsetLeft: 0 });
    };
    const showSounds = () => {
      showHTMLElements(["sounds", "tinted-overlay"]);
      centerElement({ id: "sounds", offsetTop: 0, offsetLeft: 0 });
    };
    const showCredits = () => {
      showHTMLElements(["credits-menu", "tinted-overlay"]);
      centerElement({ id: "credits-menu", offsetTop: 0, offsetLeft: 0 });
    };
    const showStart = () => {
      showHTMLElements(["start-menu", "title", "start-button", "tinted-overlay"]);
      centerElement({ id: "start-button", offsetTop: 0, offsetLeft: 0 });
      centerElement({ id: "title", offsetTop: "-25%", offsetLeft: 0 });
      centerElement({ id: "start-menu", offsetTop: "25%", offsetLeft: 0 });
    };
    const showPauseMenu = () => {
      showHTMLElements(["pause-button", "pause-menu", "game-scoreboard", "tinted-overlay"]);
      centerElement({ id: "pause-menu", offsetTop: 0, offsetLeft: 0 });
    };
    const showGameMode = () => {
      showHTMLElements(["pause-button", "game-scoreboard"]);
    };
    const goBack = () => {
      if (window.appConfig.pause) {
        showPauseMenu();
      } else {
        showStart();
      }
    };
    const centerElement = (options) => {
      const { id, offsetLeft, offsetTop } = options;
      const element = document.getElementById(id);
      const buttonHeight = element.offsetHeight;
      const buttonWidth = element.offsetWidth;
      let offsetHeight
      if (typeof offsetTop === "number") {
        offsetHeight = window.innerHeight / 2 - buttonHeight / 2 + offsetTop;
      } else {
        const parsedNum = Number.parseInt(offsetTop)
        const percentFromTop = (50 + parsedNum) / 100 //assume it's a percent between -50% and 50%
        offsetHeight = window.innerHeight * percentFromTop - buttonHeight / 2;
      }
      let offsetWidth
      if (typeof offsetLeft === "number") {
        offsetWidth = window.innerWidth / 2 - buttonWidth / 2 + offsetLeft;
      } else {
        const parsedNum = Number.parseInt(offsetLeft)
        const percentFromLeft = (50 + parsedNum) / 100 //assume it's a percent between -50% and 50%
        offsetWidth = window.innerWidth * percentFromLeft - buttonWidth / 2;
      }


      const root = document.documentElement;
      root.style.setProperty(`--${id}-offset-top`, offsetHeight + "px");
      root.style.setProperty(`--${id}-offset-left`, offsetWidth + "px");
    };

    const setFontSizes = () => {
      let hSq = window.innerHeight * window.innerHeight
      let wSq = window.innerWidth * window.innerWidth
      let diagonalLength = Math.sqrt(hSq + wSq)
      const root = document.documentElement;
      root.style.setProperty(`--font-size-0`, diagonalLength * .01 + "px");
      root.style.setProperty(`--font-size-1`, diagonalLength * .02 + "px");
      root.style.setProperty(`--font-size-2`, diagonalLength * .03 + "px");
      root.style.setProperty(`--font-size-3`, diagonalLength * .04 + "px");
      root.style.setProperty(`--font-size-4`, diagonalLength * .05 + "px");
    }
    const changeMusicVolume = (val) => {
      window.appConfig.backgroundMusics.forEach((m, mIndex) => {
        const currentVol = m.volume();
        m.fade(currentVol, val * 0.1 * 0.01, 1);
      });
    };
    const changeSFXVolume = (val) => {
      window.appConfig.howlSounds.forEach((m, mIndex) => {
        const currentVol = m.volume();
        m.fade(currentVol, val * 0.01, 1);
      });
    };
    const allElements = [
      "sounds",
      "start-menu",
      "pause-menu",
      "report",
      "level-select",
      "game-scoreboard",
      "title",
      "credits-menu",
      "start-button",
      "pause-button",
      "tinted-overlay"
    ];
    const showHTMLElements = (elements) => {
      // elements is an array of id strings
      allElements.forEach((el) => {
        document.getElementById(el).classList.add("hide");
      });
      elements.forEach((el) => {
        document.getElementById(el).classList.remove("hide");
      });
    };
    const setLevel = (level) => {
      window.appConfig.level = level;
    };
    window.onload = initScene;
  </script>
</head>

<body>
  <div class="debug hide">
  </div>
  <div id="viewport"></div>
  <div id="tinted-overlay"></div>
  <div id="game-scoreboard" class="hide">
    <div id="timer"></div>
    <div id="score"></div>
  </div>
  <div id="sounds" class="hide">
    <div id="sounds-title" class="menu-title-text">Sounds</div>
    <div class="menu-container">
      <div class="menu-big-text">
        <div class="justify-left">SFX</div>
        <div class="justify-right range-container"><input value="100" type="range" min="0" max="100"
            onmouseup="changeSFXVolume(this.value)" ontouchend="changeSFXVolume(this.value)" /></div>
      </div>
      <div class="menu-big-text">
        <div class="justify-left">Music</div>
        <input class="justify-right" value="100" type="range" min="0" max="100"
          onmouseup="changeMusicVolume(this.value)" ontouchend="changeMusicVolume(this.value)" />
      </div>
    </div>
    <button class="start-menu-button" onClick="goBack()">Back</button>
  </div>
  <div id="credits-menu" class="hide">
    <div id="credits-title" class="menu-title-text margin-bottom-2">Credits</div>
    <div class="margin-bottom-2">
      <div class="menu-big-text">Ian Lynch, Sean Lynch</div>
      <div class="menu-small-text">Programming Design</div>
    </div>
    <div class="margin-bottom-2">
      <div class="menu-big-text">Haley Rheinhart, Sean Lynch</div>
      <div class="menu-small-text">UX Design</div>
    </div class="margin-bottom-2">
    <div>
      <div class="menu-big-text">Haley Rheinhart</div>
      <div class="menu-small-text">Music & Sound Design</div>
    </div>
    <button class="start-menu-button" onClick="goBack()">Back</button>
  </div>
  <div id="report" class="hide">
    <table>
      <tr>
        <td>Time:</td>
        <td id="report-time"></td>
      </tr>
      <tr>
        <td>Crystals:</td>
        <td id="report-coins"></td>
      </tr>
      <tr>
        <td>Score:</td>
        <td id="report-score"></td>
      </tr>
    </table>
    <div id="report-options">
      <button id="report-level-select-button" class="start-menu-button" onClick="showLevelSelect()">
        Level Select
      </button>
      <button id="report-reset-button" class="start-menu-button" onClick="reset({action:'reset'})">
        Try Again
      </button>
      <button id="report-reset-button" class="start-menu-button" onClick="reset({action:'next'})">
        Next Level
      </button>
    </div>
  </div>
  <div id="level-select" class="hide">
    <div id="level-select-title">Level Select</div>
    <table>
      <tr>
        <td class="level-select-button" onClick="setLevel(1)">1</td>
        <td class="level-select-button" onClick="setLevel(2)">2</td>
        <td class="level-select-button" onClick="setLevel(3)">3</td>
        <td class="level-select-button" onClick="setLevel(4)">4</td>
        <td class="level-select-button" onClick="setLevel(5)">5</td>
      </tr>
      <tr>
        <td class="level-select-button" onClick="setLevel(6)">6</td>
        <td class="level-select-button" onClick="setLevel(7)">7</td>
        <td class="level-select-button" onClick="setLevel(8)">8</td>
        <td class="level-select-button" onClick="setLevel(9)">9</td>
        <td class="level-select-button" onClick="setLevel(10)">10</td>
      </tr>
      <tr>
        <td class="level-select-button" onClick="setLevel(11)">11</td>
        <td class="level-select-button" onClick="setLevel(12)">12</td>
        <td class="level-select-button" onClick="setLevel(13)">13</td>
        <td class="level-select-button" onClick="setLevel(14)">14</td>
        <td class="level-select-button" onClick="setLevel(15)">15</td>
      </tr>
      <tr>
        <td class="level-select-button" onClick="setLevel(16)">16</td>
        <td class="level-select-button" onClick="setLevel(17)">17</td>
        <td class="level-select-button" onClick="setLevel(18)">18</td>
        <td class="level-select-button" onClick="setLevel(19)">19</td>
        <td class="level-select-button" onClick="setLevel(20)">20</td>
      </tr>
      <tr>
        <td class="level-select-button" onClick="setLevel(21)">21</td>
        <td class="level-select-button" onClick="setLevel(22)">22</td>
        <td class="level-select-button" onClick="setLevel(23)">23</td>
        <td class="level-select-button" onClick="setLevel(24)">24</td>
        <td class="level-select-button" onClick="setLevel(25)">25</td>
      </tr>
    </table>
    <button class="start-menu-button" onClick="goBack()">Back</button>
  </div>

  <div id="pause-menu" class="hide">
    <button id="pause-level-select-button" class="start-menu-button" onClick="pause()">
      Resume
    </button>
    <button id="pause-level-select-button" class="start-menu-button" onClick="showLevelSelect()">
      Level Select
    </button>
    <button id="pause-sounds-button" class="start-menu-button" onClick="showSounds()">
      Sounds
    </button>
    <button id="pause-reset-button" class="start-menu-button" onClick="reset({action:'reset'})">
      Restart Level
    </button>
  </div>
  <div id="title">BALLSINKI</div>
  <button id="start-button" onClick="start()">Start</button>
  <div id="start-menu">
    <button id="start-level-select-button" class="start-menu-button" onClick="showLevelSelect()">
      Level Select
    </button>
    <button id="start-sounds-button" class="start-menu-button" onClick="showSounds()">
      Sounds
    </button>
    <button id="start-credits-button" class="start-menu-button" onClick="showCredits()">
      Credits
    </button>
  </div>
  <img src="images/pause.png" id="pause-button" disabled class="hide" onClick="pause()" />
  <div id="curtain"></div>
</body>
<script>
    // window.console.log = () => {}
    // window.console.warn = () => {}
    // window.console.dir = () => {}
</script>

</html>